<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8"/>
<title>Meshcraft</title>
<link rel="shortcut icon" href="/favicon.ico" />

	
<!--                                                     _.._
                                                      .-'_.._''.
 __  __   ___       _....._              .          .' .'     '.\
|  |/  `.'   `.   .´       '.          .'|         / .'                                _.._
|   .-.  .-.   ' /   .-'"'.  \        (  |        . '            .-,.-~.              .' .._|    .|
|  |  |  |  |  |/   /______\  |        | |        | |            |  .-. |    __      | '      .' |_
|  |  |  |  |  ||   __________|    _   | | .'''-. | |            | |  | | .:-`.'.  __| |__  .'     |
|  |  |  |  |  |\  (          '  .' |  | |/.'''. \. '            | |  | |/ |   \ ||__   __|'-..  .-'
|  |  |  |  |  | \  '-.___..-~. .   | /|  /    | | \ '.         .| |  '- `" __ | |   | |      |  |
|__|  |__|  |__|  `         .'.'.'| |//| |     | |  '. `.____.-'/| |      .'.''| |   | |      |  |
                   `'-.....-.'.'.-'  / | |     | |    `-._____ / | |     / /   | |_  | |      |  '.'
                                 \_.'  | '.    | '.           `  |_|     \ \._,\ '/  | |      |   /
                                       '___'   '___'                      `~~'  `"   |_|      `'--> 

<script type="text/javascript">//<![CDATA[

/* Coding guide to Object Orientation used here: 
   _prefix denotes a private property, there should never be something else than this._something.
   Class_function denotes a static function for this class.
*/

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.---.     .  .
\___  ,-. |- |- . ,-. ,-. ,-.
    \ |-' |  |  | | | | | `-.
`---' `-' `' `' ' ' ' `-| `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~,| ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
                       `'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* if true catch all errors and report to user,    
 * if false let them pass through to e.g. firebug. */
var enableCatcher = false;
var debugNodes = true;

settings = {
	/* milliseconds after mouse down, dragging starts */
	dragtime : 400,
	
	/* pixels after mouse down and move, dragging starts */
	dragbox  : 10,
	
	/* minimum size for notes */
	noteMinSizeX : 40,
	noteMinSizeY : 40,
	
	/* note style */
	noteTextBorder : 10,
	noteInnerBorderWidth : 2,
	noteInnerBorderColor : "#ffbc57",
	noteBackground1 : "rgba(255,255,248,0.935)",
	noteBackground2 : "rgba(255,255,160,0.935)",
	
	/* selection */
	//selectionColor : "#8080ff",
	selectionColor : "rgba(243,203,255,0.9)",
	
	/* scrollbar */
	scrollbarFillStyle : "#ffbc57",
	scrollbarStrokeStyle : "#dd9a34",
	scrollbarLineWidth : 2,
	scrollbarRadius  : 4,
	scrollbarMarginX : 7,
	scrollbarMarginY : 5,
	
	/* size of resize handles */
	handleSize : 10,
	handleDistance : 0,
	handleColor1 : "rgb(125,120,32)",
	handleWidth1 : 3,
	handleColor2 : "rgb(255,180,90)",
	handleWidth2 : 1,
	
	/* blink speed of the caret */
	caretBlinkSpeed : 530,	
};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--.      .
 ' |   \ ,-. |-. . . ,-.
 , |   / |-' | | | | | |
 `-^--'  `-' ^-' `-^ `-|
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ,|~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~                       
 Prints out messages  `' and objects on the console.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function debug() {
	var l = "";
	for(var i = 0; i < arguments.length; i++) {
		if (i > 0) { 
			l += " ";
		}
		var a = arguments[i];
		if (a == null) {
			l += "|null|";
		} else if (a.substring || typeof(a) != "object") {
			l += a;
		} else {
			l += "{";
			var first = true;
			for (p in a) {
				if (!first) {
					l += ", ";
				} else {
					first = false;
				}
				switch (typeof(a[p])) {
				case "function" : 
					l += p + " : function";
					break;
				default:
					l += p  + " : " + a[p];
					break;
				}
			}
			l += "}";
		}
	}
	console.log(l);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.-,--.
 `\__  ,-. . . ,-,-. ,-.
  /    | | | | | | | `-.
 '`--' ' ' `-^ ' ' ' `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
var enums = {
	/* Mouse state */
	MST_NONE   : 0, /* button is up */
	MST_ATWEEN : 1, /* just came down, unsure if click or drag */
	MST_DRAG   : 2, /* mouse is dragging */

	/* interface action active */
	ACT_NONE    : 0,
	ACT_PAN     : 1,
	ACT_IDRAG   : 2,
	ACT_IRESIZE : 3,
	ACT_SCROLLY : 4,
	ACT_MENU    : 6,
};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ,--.             .  
 | `-' ,-. ,-. ,-. |- 
 |   . ,-| |   |-' |  
 `--'  `-^ '   `-' `' 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Caret() {
	/* the item the caret isin */
	this.item = null;
	/* element the caret is in */
	this.element = null;
	/* position of the caret in the element */
	this.offset = 0;
	/* true if visible */
	this.shown = false;
	/* true when just blinked away */
	this.blink = false;	
}
	
/* shows the caret or resets the blink timer if already shown */
Caret.prototype.show = function() {
	this.shown = true;
	this.blink = false;
	system.startBlinker();
}
	
/* hides the caret */
Caret.prototype.hide = function() {
	this.shown = false;
	system.stopBlinker();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .---.     .          .
 \___  ,-. |  ,-. ,-. |- . ,-. ,-.
     \ |-' |  |-' |   |  | | | | |
 `---' `-' `' `-' `-' `' ' `-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Selection() {
	this.active = false;
	this.item = null;
	this.element1 = null;
	this.element2 = null;
	this.offset1 = 0;
	this.offset2 = 0;
	this.inner = null;
}	

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.-,--.   .   .
 `\__  ,-| . |- ,-. ,-.
  /    | | | |  | | |
 '`--' `-^ ' `' `-' '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Editor() {
	this.caret     = new Caret();
	this.selection = new Selection();
	this.item      = null;
}

/* draws or erases the caret */
Editor.prototype.updateCaret = function() {
	var cx = system.canvas.getContext("2d");
	var caret = this.caret;
	if (caret.save) {
		/* erase the old caret */
		cx.putImageData(caret.save, caret.sx - 1, caret.sy - 1);
		caret.save = null;
	} 
	if (caret.shown && !caret.blink) {
		/* todo cache position */
		cx.font = caret.item.dtree.font;
		var ce  = caret.element;
		var t   = ce.text;
		var co  = caret.offset;
		var pchunk, pline;
		var cpara = ce.anchestor("paragraph");
		var aswbuf = {};
		cpara.findByOffset(co, aswbuf);
		var pline  = aswbuf.line;
		var pchunk = aswbuf.chunk;
		var x = system.space.pox + caret.item.x + cpara.x + (pchunk != null ? pchunk.x : pline.x);
		var y = system.space.poy + caret.item.y + cpara.y + pline.y;
		if (caret.item.scrolly > 0) {
			y -= caret.item.scrolly;
		}
		var cow; /* offset width for the caret */
		if (pchunk == null) {
			cow = 0;
		} else {
			var ts = t.substring(pchunk.offset, co);
			cow = cx.measureText(ts).width
		}
		var ts = caret.item.dtree.textsize;
		var th = Math.round(ts * 1.2);
		x += cow;
		y -= ts;
		caret.save = cx.getImageData(
			(caret.sx = x) - 1, 
			(caret.sy = y) - 1, 
			caret.sh = 3, 
			caret.sw = th + 1);
		cx.fillRect(x, y, 1, th);
	}
}	
	
/* got a special key */
/* returns redraw code telling if the element needs to be redrawn. */
Editor.prototype.specialKey = function(keycode, shiftKey) {
	if (!this.item) {
		return false;
	}
	var refresh = false;
	var redraw = false;
	var caret  = this.caret;
	
	switch(keycode) {
	case  8 : // backspace
	{
		var co = caret.offset;
		var ce = caret.element;
		if (co > 0) {
			var t = ce.text;
			ce.text = t.substring(0, co - 1) + t.substring(co, t.length);
			caret.offset--;
			redraw = true;
		} else {
			var para = ce.anchestor("paragraph");
			redraw = para.joinToPrevious(ce, caret);
		}
		break;
	}
	case 13 : // return
	{
		var ce    = caret.element;
		var co    = caret.offset;			
		var ct    = ce.text;
		/* todo multi node ability */
		var opara = ce.anchestor("paragraph");
			
		ce.text = ct.substring(0, co);
		var npara = new Paragraph(ct.substring(co, ct.length));
		opara.parent.insertBefore(npara, opara.next);
		caret.element = npara.first;
		caret.offset  = 0;			
		redraw = true;
		break;
	}
	case 35 : // end
	{
		caret.offset = caret.element.text.length;
		refresh = true;
		break;
	}
	case 36 : // pos1
	{
		caret.offset = 0;
		refresh = true;
		break;
	}
	case 37 : // left
	{
		if (caret.offset > 0) {
			caret.offset--;
		} else {
			var ce = caret.element;
			var para = ce.parent;
			var prespara = para.prev;
			if (!prespara) {
				return false;
			}
			ce = caret.element = prespara.last;
			caret.offset = ce.text.length;
		}
		refresh = true;
		break;
	}
	case 38 : // up
		/* todo, do properly */
		var ce = caret.element;
		var pprev = ce.parent.prev;
		if (!pprev) {
			return false;
		}
		ce = caret.element = pprev.first;
		var ct = ce.text;
		if (caret.offset > ct.length) {
			caret.offset = ct.length;
		}
		refresh = true;
		break;
	case 39 : // right
	{	
		var ce = caret.element;
		var ct = ce.text;
		var be = ce;
		var bo = caret.offset;
			
		if (caret.offset < ct.length) {
			caret.offset++;
		} else {
			var pnext = ce.parent.next;
			if (!pnext) {
				break;
			}
			caret.element = pnext.first;
			caret.offset = 0;
		}
		var selection = this.selection;
		if (shiftKey) {
			if (!selection.active) {
				selection.active = true;
				selection.item = this.item;
				selection.element1 = be;
				selection.offset1 = bo;
			}
			selection.element2 = caret.element;
			selection.offset2 = caret.offset;
			redraw = true;
		} else {
			if (selection.active) {
				selection.active = false;
				//selection.dropCaches();					
				redraw = true;
			} 
		}
		refresh = true;
		break;
	}
	case 40 : // down
	{	
		/* todo, do properly */
		var ce = caret.element;
		var pnext = ce.parent.next;
		if (!pnext) {
			return false;
		}
		ce = caret.element = pnext.first;
		var ct = ce.text;
		if (caret.offset > ct.length) {
			caret.offset = ct.length;
		}
		refresh = true;
		break;
	}
	case 46 : // del
	{
		var co = caret.offset;
		var ce = caret.element;
		var ct = ce.text;
		if (co < ct.length) {
			ce.text = ct.substring(0, co) + ct.substring(co + 1, ct.length);
			redraw = true;
		} else {
			var para = ce.anchestor("paragraph");
			redraw = para.joinToNext(ce, caret);
		}
		break;
	}
	default :
		break;
	}
	if (refresh || redraw) {
		caret.show();
	}
	if (refresh && !redraw) {
		this.updateCaret();
	}
	return redraw;
}

/* blinks the caret away or into visiblity */
Editor.prototype.blink = function() {
	if (this.caret.shown) {
		this.caret.blink = !this.caret.blink;
		this.updateCaret();			
	}
}
	
/* got character input from user */
/* returns redraw needs */
Editor.prototype.input = function(text) {
	if (!this.item) {
		return false;
	}
	var caret = this.caret;
	for(var ci = 0; ci < text.length; ci++) {
		var ch = text[ci];
		var ce = caret.element;
		var co = caret.offset;
		var ct = ce.text;
		ce.text = ct.substring(0, co) + ch + ct.substring(co, ct.length);
		this.caret.offset++;
	}
	return true;
}
				
/* editor got systemFocus */
Editor.prototype.systemFocus = function() {
	if (this.item) {
		this.caret.show();
		this.updateCaret();
	}
}

/* editor got systemFocus */
Editor.prototype.systemBlur = function() {
	this.caret.hide();
}

/* editor focuses one item */
Editor.prototype.focus = function(item) {
	this.item = item;
	var caret = this.caret;
	caret.item = item;
	caret.element = item.dtree.first.first;
	caret.offset = 0;
}
		
/* editor disconnects */
Editor.prototype.blur = function() {
	this.caret.hide();
	this.item = null;
	this.caret.element = null;
	this.caret.offset = null;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .---.         .
 \___  . . ,-. |- ,-. ,-,-.
     \ | | `-. |  |-' | | |
 `---' `-| `-' `' `-' ' ' '
~ ~ ~ ~ /|~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  Base-`-'-system for Meshcraft. 
  All system events arrive here.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 
/* Catches all errors for a function */
function System_makeCatcher(that, fun) {
	return function() {
		if (enableCatcher) {
			try {
				fun.apply(that, arguments);
			} catch(err) {
				alert("Internal failure, " + err.name + ": " + err.message + "\n\n" + 
				      "file: " + err.fileName + "\n" + 
					  "line: " + err.lineNumber + "\n" + 
					  "stack: " + err.stack);
			}
		} else {
			fun.apply(that, arguments);
		}
	};
}

var system = { 
init : function() {
	System_makeCatcher(system, system._init)();
},

_init : function() {
	var canvas = this.canvas = document.getElementById("canvas");
	canvas.width  = window.innerWidth - 1;
	canvas.height = window.innerHeight - 1;
	var cx = canvas.getContext("2d");
	
	/* the space that currently is displayed */
	system.space = null;
	
	/* mouse state */
	var mst = enums.MST_NONE;
	/* position the mouse went down to atween state */
	var msx = null;
	var msy = null;
	/* latest mouse position seen in atween state */
	var mmx = null;
	var mmy = null;
	/* timer for atween state */
	var atweenTimer = null;

	var editor = system.editor = new Editor();
	
	/* hidden input that forwards all events */
	var hiddenInput = document.getElementById("input");
	
	/* remembers last SpecialKey pressed, to hinder double events.
	 * Opera is behaving stupid here. */
	var lastSpecialKey = -1;
	
	/* a special key is pressed */
	function specialKey(keyCode, shiftKey) {
		switch(keyCode) {
		case  8 : // backspace
		case 13 : // return
		case 35 : // end
		case 36 : // pos1
		case 37 : // left
		case 38 : // up
		case 39 : // right
		case 40 : // down
		case 46 : // del
			system.space.specialKey(keyCode, shiftKey);
			return false;
		default : 
			return true;
		}
	}
	
	/*-- Functions the browser calls --*/
	
	/* tests if the hidden input field got data */
	function testinput() {
		var text = hiddenInput.value;
		if (text == "") {
			return;
		}
		hiddenInput.value = "";
		system.space.input(text);
	}
	
	/* do a blink */
	function blink() {
		/* hackish, also look into the hidden input field, 
		 * maybe the user pasted something using the browser menu. */
		testinput();
		editor.blink();
	}
	
	/* key down in hidden input field */
	function onkeydown(event) {
		var pass = specialKey(lastSpecialKey = event.keyCode, event.shiftKey);
		if (!pass) event.preventDefault();
	}
		
	/* hidden input key press */
	function onkeypress(event) {
		var ew = event.which;
		var ek = event.keyCode;
		if (((ek > 0 && ek < 32) || ew == 0) && lastSpecialKey != ek) {
			lastSpecialKey = -1;
			return specialKey(ek, event.shiftKey);
		}
		lastSpecialKey = -1;
		testinput();
		setTimeout("system.ontestinput();", 0);
		return true;
	}

	/* hidden input key up */
	function onkeyup(event) {
		testinput();
		return true;
	}
	
	/* hidden input lost focus */
	function onblur(event) {
		system.space.systemBlur();
	}
	
	/* hidden input got focus */
	function onfocus(event) {
		system.space.systemFocus();
	}
		
	/* view window resized */
	function onresize(event) {
		/* todo debouncing */
		canvas.width  = window.innerWidth - 1;
		canvas.height = window.innerHeight - 1;	
		system.space && system.space.redraw();
	}
	
	/* mouse move event */
	function onmousemove(event) {
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;

		switch(mst) {
		case enums.MST_NONE :
			system.space.mousehover(x, y);
			return true;
		case enums.MST_ATWEEN :
		{
			var dragbox = settings.dragbox;
			if ((Math.abs(x - msx) > dragbox) || (Math.abs(y - msy) > dragbox)) {
				/* moved out of dragbox -> start dragging */
				clearTimeout(atweenTimer);
				atweenTimer = null;
				mst = enums.MST_DRAG;
				system.space.dragstart(msx, msy);
				if (x != msx || y != msy) {
					system.space.dragmove(x, y);
				}
				this.captureEvents();
			} else {
				/* saves position for possible atween timeout */
				mmx = x;
				mmy = y;
			}
			return true;
		}
		case enums.MST_DRAG :
			system.space.dragmove(x, y);
			return true;
		default :
			throw new Error("invalid mst");
		}
	}
	
	/* mouse down event */
	function onmousedown(event) {
		event.preventDefault();
		hiddenInput.focus();
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;
		/* asks the space if it forces this to be a drag or click, or yet unknown */
		mst = system.space.mousedown(x, y);
		switch(mst) {
		case enums.MST_ATWEEN :
			msx = mmx = x;
			msy = mmy = y;
			atweenTimer = setTimeout("system.onatweentime();", settings.dragtime);
			break;
		case enums.MST_DRAG :
			this.captureEvents();
			break;
		}	
		return false;
	}

	/* mouse up event */
	function onmouseup(event) {
		event.preventDefault();
		system.releaseEvents();
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;
		
		switch (mst) {
		case enums.MST_NONE :
			console.log("mouse up, without down?");
			return false;
		case enums.MST_ATWEEN :
			/* this was a click */
			clearTimeout(atweenTimer);
			atweenTimer = null;
			system.space.click(x, y);
			mst = enums.MST_NONE;
			return false;
		case enums.MST_DRAG :
			system.space.dragstop(x, y);
			mst = enums.MST_NONE;
			return false;
		}
	}

	/* timeout after mouse down so dragging starts */
	function onatweentime() {
		if (mst != enums.MST_ATWEEN) {
			console.log("dragTime() in wrong action mode");
			return;
		}
		mst = enums.MST_DRAG;
		atweenTimer = null;
		system.space.dragstart(msx, msy);
		if (mmx != msx || mmy != msy) {
			system.space.dragmove(mmx, mmy);
		}
	}
	
	/* double click */
	/*function ondblclick(event) {	
		event.preventDefault();
		system.space.dblclick(event);
		return false;
	}*/
	
	canvas.onmouseup       = System_makeCatcher(this, onmouseup);
	canvas.onmousemove     = System_makeCatcher(this, onmousemove);
	canvas.onmousedown     = System_makeCatcher(this, onmousedown);
	//canvas.ondblclick      = System_makeCatcher(this, ondblclick);
	window.onresize        = System_makeCatcher(this, onresize);
	hiddenInput.onfocus    = System_makeCatcher(this, onfocus);
	hiddenInput.onblur     = System_makeCatcher(this, onblur);
	hiddenInput.onkeydown  = System_makeCatcher(this, onkeydown);
	hiddenInput.onkeypress = System_makeCatcher(this, onkeypress);
	hiddenInput.onkeyup    = System_makeCatcher(this, onkeyup);
	this.ontestinput       = System_makeCatcher(this, testinput);
	this.onatweentime      = System_makeCatcher(this, onatweentime);
	this.onblink           = System_makeCatcher(this, blink);
	
	/* if true use browser supported setCapture() call
	 * if false work around */
	var useCapture = canvas.setCapture != null;
	
	/* sets the mouse cursor */
	system.setCursor = function(cursor) {
		canvas.style.cursor = cursor;
	}		
	
	/*-- Meshcraft System calls --*/
	
	/* clears the canvas */
	system.canvasClear = function() {
		cx.clearRect(0, 0, canvas.width, canvas.height);
		//canvas.width = canvas.width;
	}
	
	/* captures all mouseevents event beyond the canvas (for dragging) */ 
	/* todo make private */
	system.captureEvents = function() {
		if (useCapture) {
			canvas.setCapture(canvas);
		} else {
			document.onmouseup = onmouseup;
			document.onmousemove = onmousemove;
		}
	}
	
	/* stops capturing all mouseevents */
	system.releaseEvents = function() {
		if (useCapture) {
			canvas.releaseCapture(canvas);
		} else {
			document.onmouseup = null;
			document.onmousemove = null;
		}
	}
	
	/* the blink (and check input) timer */
	var blinkTimer = null;
	
	/* (re)starts the blink timer */
	system.startBlinker = function() {
		if (blinkTimer) {
			clearInterval(blinkTimer);
		} 
		testinput();
		blinkTimer = setInterval("system.onblink()", settings.caretBlinkSpeed);		
	}
	
	/* stops the blink timer */
	system.stopBlinker = function() {
		if (blinkTimer) {
			clearInterval(blinkTimer);
		} 		
	}
		
	system.startBlinker();
	delete system.init;

	// -v-v-v- testing code here -v-v-v-v-
	var space = system.space = new Space();
	//var note1 = new Note(220, 65);
	//var note1 = new Note(320, 90);
	var note2 = new Note(500, 200);
	var vector1 = null;
	//vector1 = new VectorGraph(850, 200, note2.doc);
	//if (vector1) {
	//	space.addItem(vector1,  10,  10);
	//}
	//space.addItem(note1,    10,  10);
	//space.addItem(note2,   250, 240);
	space.addItem(note2,   50, 40);
	{
		var a=[];
		var n=0;
a[n++]="                                                         _.._";
a[n++]="                                                      .-'_.._''.";
a[n++]=" __  __   ___       _....._              .          .' .'     '.\\";
a[n++]="|  |/  `.'   `.   .´       '.          .'|         / .'                                _.._";
a[n++]="|   .-.  .-.   ' /   .-'\"'.  \\        (  |        . '            .-,.-~.              .' .._|    .|";
a[n++]="|  |  |  |  |  |/   /______\\  |        | |        | |            |  .-. |    __      | '      .' |_";
a[n++]="|  |  |  |  |  ||   __________|    _   | | .'''-. | |            | |  | | .:-`.'.  __| |__  .'     |";
a[n++]="|  |  |  |  |  |\\  (          '  .' |  | |/.'''. \\. '            | |  | |/ |   \\ ||__   __|'-..  .-'";
a[n++]="|  |  |  |  |  | \\  '-.___..-~. .   | /|  /    | | \\ '.         .| |  '- `\" __ | |   | |      |  |";
a[n++]="|__|  |__|  |__|  `         .'.'.'| |//| |     | |  '. `.____.-'/| |      .'.''| |   | |      |  |";
a[n++]="                   `'-.....-.'.'.-'  / | |     | |    `-._____ / | |     / /   | |_  | |      |  '.'";
a[n++]="                                 \\_.'  | '.    | '.           `  |_|     \\ \\._,\\ '/  | |      |   /";
a[n++]="                                       '___'   '___'                      `~~'  `\"   |_|      `'~~/";
		for(var i = 0; i < n; i++) {
//			note1.dtree.append(new Paragraph(a[i]));
		}
	}
	//note1.doc.textsize = 13;
	//note1.dtree.textsize = 3;
	//note1.dtree.font = note1.dtree.textsize + "px monospace";
	//note1.dtree.pre = true;
	
	//var draw = window.localStorage.getItem("draw");
	var draw = "";
	if (draw) {
		var reg = /([^\n]+)$/gm;
		for(var ca = reg.exec(draw); ca != null; ca = reg.exec(draw)) {
			note2.append(new Paragraph(ca[1]));
		}
		note2.doc.textsize = 10;
		note2.doc.font = note2.doc.textsize + "px monospace";
		note2.doc.pre = true;
	} else {
		var d = note2.dtree;
		d.append(new Paragraph("Lorem ipsum dolor sit amet, consectetur adipiscing elit. In sollicitudin tortor vehicula tellus vestibulum quis pharetra augue faucibus. Integer id quam urna. Aliquam accumsan pulvinar luctus. Fusce tincidunt, sapien posuere interdum rutrum, mauris ante consequat ipsum, id tincidunt nisl turpis ut lectus. Sed in elit ut neque placerat malesuada non vel turpis. Integer congue sem commodo justo pretium vestibulum. Pellentesque at libero eget quam blandit molestie. Nunc in lacus massa, quis faucibus justo. Aliquam vitae tellus nulla. Vestibulum at tortor sit amet ligula bibendum iaculis quis vitae sapien. Integer pellentesque ullamcorper arcu, volutpat aliquam mi viverra vel. Integer mollis, augue at pellentesque tristique, ante magna rutrum urna, vel sagittis sem elit in augue."));
		
		//d.append(new Paragraph("Lorem ipsum dolor sit amet, consectetur adipiscing elit. In sollicitudin tortor vehicula tellus vestibulum quis pharetra augue faucibus. Integer id quam urna. Aliquam accumsan pulvinar luctus."));
		//d.append(new Paragraph("Fusce tincidunt, sapien posuere interdum rutrum, mauris ante consequat ipsum, id tincidunt nisl turpis ut lectus. Sed in elit ut neque placerat malesuada non vel turpis. Integer congue sem commodo justo pretium vestibulum. Pellentesque at libero eget quam blandit molestie. Nunc in lacus massa, quis faucibus justo."));
		//d.append(new Paragraph("Aliquam vitae tellus nulla. Vestibulum at tortor sit amet ligula bibendum iaculis quis vitae sapien. Integer pellentesque ullamcorper arcu, volutpat aliquam mi viverra vel. Integer mollis, augue at pellentesque tristique, ante magna rutrum urna, vel sagittis sem elit in augue."));
		//d.append(new Paragraph("Nam eros nunc, egestas porttitor pharetra sit amet, egestas eleifend eros. Nulla mauris felis, cursus eget tincidunt sed, pretium quis nibh. Proin pulvinar, enim sit amet tincidunt varius, diam risus bibendum augue, sed facilisis lectus massa in sem. Duis ac felis libero."));
	}
	space.redraw();	
}};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hexagon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* shortcut globas, dirty :( */
var pi  = Math.PI;
var pi3 = Math.PI / 3;
var pi6 = Math.PI / 6;
var sin = Math.sin;
var cos = Math.cos;
var hexsin = [ sin(pi6 + pi3 * 1), sin(pi6 + pi3 * 2), sin(pi6 + pi3 * 3),
               sin(pi6 + pi3 * 4), sin(pi6 + pi3 * 5), sin(pi6 + pi3 * 6) ];
var hexcos = [ cos(pi6 + pi3 * 1), cos(pi6 + pi3 * 2), cos(pi6 + pi3 * 3),
               cos(pi6 + pi3 * 4), cos(pi6 + pi3 * 5), cos(pi6 + pi3 * 6) ];
	
function drawHexagon(cx, x, y) {
	var rad = 20;
	cx.beginPath();
	cx.moveTo(x + hexsin[0] * rad, y + hexcos[0] * rad);
	for(var i = 1; i < 6; i++) {
		cx.lineTo(x + hexsin[i] * rad, y + hexcos[i] * rad);
	}
	cx.lineTo(x + hexsin[0] * rad, y + hexcos[0] * rad);
	cx.closePath();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.---.                 
\___  ,-. ,-. ,-. ,-. 
    \ | | ,-| |   |-' 
`---' |-' `-^ `-' `-' 
~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Space() {
	/* all items in the space */
	this._items = []; 
	
	this.iaction = { /* todo private? */
		act : enums.ACT_NONE,
	};
			
	/* panning offset */
	this.pox = 0;
	this.poy = 0;
}

/* redraws the complete space */
Space.prototype.redraw = function() {
	var items = this._items;
	var editor = system.editor;
	var canvas = system.canvas;
	system.canvasClear();
	editor.caret.save = null;
	var cx = canvas.getContext("2d");
	
	for(var i = items.length - 1; i >= 0; i--) {
		var it = items[i];
		cx.drawImage(it.getCanvas(editor.selection), it.x + this.pox, it.y + this.poy);
	}
		
	/* draws resize handles */
	if (editor.item) {
		cx.save();
		var it = editor.item;
		var ds = settings.handleDistance; 			
		var hs = settings.handleSize;
		var hs2 = hs / 2;
			
		var x1 = it.x + 0.5 - ds + this.pox;
		var y1 = it.y + 0.5 - ds + this.poy;
		var x2 = x1 + it.width  + 2*ds - 1;
		var y2 = y1 + it.height + 2*ds - 1;
		var xm = Math.round((x1 - 0.5 + x2) / 2) + 0.5;
		var ym = Math.round((y1 - 0.5 + y2) / 2) + 0.5;
		
		cx.moveTo(x1, y1 + hs);  cx.lineTo(x1, y1); cx.lineTo(x1 + hs, y1);
		cx.moveTo(xm - hs2, y1); cx.lineTo(xm + hs2, y1);
		cx.moveTo(x2 - hs,  y1); cx.lineTo(x2, y1); cx.lineTo(x2, y1 + hs);
		cx.moveTo(x2, ym - hs2); cx.lineTo(x2, ym + hs2);
		cx.moveTo(x2, y2 - hs);  cx.lineTo(x2, y2); cx.lineTo(x2 - hs, y2);
		cx.moveTo(xm - hs2, y2); cx.lineTo(xm + hs2, y2);
		cx.moveTo(x1 + hs, y2);  cx.lineTo(x1, y2); cx.lineTo(x1, y2 - hs);
		cx.moveTo(x1, ym - hs2); cx.lineTo(x1, ym + hs2);
			
		cx.strokeStyle = settings.handleColor1;
		cx.lineWidth = settings.handleWidth1;
		cx.stroke(); 
		cx.strokeStyle = settings.handleColor2;
		cx.lineWidth = settings.handleWidth2;
		cx.stroke(); 
		cx.beginPath(); 
		cx.restore();
	}
		
	editor.updateCaret();
		
	if (this.iaction.act == enums.ACT_MENU) {
		this.drawMenu();
	}
}
		
/* adds an item to the space */
Space.prototype.addItem = function(item, x, y) {
	this._items.push(item);
	item.x = x;
	item.y = y;
}

/* draws a menu */
/* todo make an own object */
Space.prototype.drawMenu = function() {
	var cx = system.canvas.getContext("2d");
	var iaction = this.iaction;
	drawHexagon(cx, iaction.sx, iaction.sy);
	cx.stroke();
	cx.fillStyle = "#ffcc88";
	if (iaction.mhover == 0) {
		cx.fill();
	}
}

/* user pressed a special key */
Space.prototype.specialKey = function(keyCode, shiftKey) {
	var rv = system.editor.specialKey(keyCode, shiftKey);
	if (rv) {
		this.redraw();
	}
}

/* user entered normal text (one character or more) */
Space.prototype.input = function(text) {
	if (system.editor.input(text)) {
		this.redraw();		
	}
}

/* the canvas/space got focus from the system*/
Space.prototype.systemFocus = function() {
	system.editor.systemFocus();
}

/* the canvas/space lost system focus */
Space.prototype.systemBlur = function() {
	system.editor.systemBlur();
}

/* gives one item the keyboard focus */
Space.prototype.focus = function(item) {
	item.focus(system.editor);
}

/* returns the item offset at position x, y */	
Space.prototype.itoAtXY = function(x, y) {
	for(var i = 0, len = this._items.length; i < len; i++) {
		var it = this._items[i];
		if (x >= it.x && y >= it.y &&  x <= it.x + it.width && y <= it.y + it.height) {
			return i;
		}
	}
	return -1;
}

/* returns the compass of the resize handles of an item */
function checkItemCompass(it, x, y) { /* todo move to item */
	var d = settings.handleSize;
	/* resize */
	var n = y >= it.y - d && y <= it.y + d;
	var e = x >= it.x + it.width - d && x <= it.x + it.width + d;
	var s = y >= it.y + it.height - d && y <= it.y + it.height + d;
	var w = x >= it.x - d && x <= it.x + d;
	
	if (n) {
		if (w) { 
			return "nw";
		} else if (e) {
			return "ne";
		} else {
			var mx = it.x + it.width / 2;
			if (x >= mx - d && x <= mx + d) {
				return "n";
			}
		}
	} else if (s) {
		if (w) {
			return "sw";
		} else if (e) {
			return "se";
		} else {
			var mx = it.x + it.width / 2;
			if (x >= mx - d && x <= mx + d) {
				return "s";
			}
		}
	} else if (w) {
		var my = it.y + it.height / 2;
		if (y >= my - d && y <= my + d) {
			return "w";
		}
	} else if (e) {
		var my = it.y + it.height / 2;
		if (y >= my - d && y <= my + d) {
			return "e";
		}
	}
	return null;
}


/* mouse hover */
Space.prototype.mousehover = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var com = null;
	var editor = system.editor;
	if (editor.item) {
		var it = editor.item;
		com = checkItemCompass(it, x, y);
		if (com) {
			system.setCursor(com + "-resize");					
		}
	}
	if (!com) {
		var ito = this.itoAtXY(x, y); /* todo give a better name */
		if (ito < 0) {
			system.setCursor("crosshair");
		} else {
			//var ch = it.atXY(x - it.x, y - it.y);
			system.setCursor("default");					
		}
	}
}

/* starts an operation with the mouse held down */
Space.prototype.dragstart = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var editor  = system.editor;
	var iaction = this.iaction; /* todo make underscored */
	var redraw = false;

	var ito = this.itoAtXY(x, y);
	if (ito < 0) {
		/* panning */
		iaction.act = enums.ACT_PAN;
		iaction.sx = x;
		iaction.sy = y;
		system.captureEvents();
		system.setCursor("pointer");
		return;
	} 
	
	/* dragging or scrolling */
	var it = this._items[ito];
	if (ito > 0) {
		/* moves item to top */
		this._items.splice(ito, 1);
		this._items.unshift(it);
		ito = 0;
		redraw = true;
	}
	/*  focus the item */
	if (editor.item != it) {
		it.focus(editor);
	}

	var srad = settings.scrollbarRadius;
	var sbmx = settings.scrollbarMarginX;
	if (it.scrolly >= 0 && Math.abs(x - it.x - it.width + srad + sbmx) <= srad +1)  {
		iaction.act = enums.ACT_SCROLLY; 
		iaction.item = it;
		iaction.sy   = y;
		iaction.ssy  = it.scrolly;
	} else {
		iaction.act = enums.ACT_IDRAG;
		iaction.item = it;
		iaction.sx = x - it.x;
		iaction.sy = y - it.y;
		system.setCursor("move");
	}
	if (redraw) {
		this.redraw();
	}
}

/* a click is a mouse down followed within dragtime by 'mouseup' and
 * not having moved out of 'dragbox'. */
Space.prototype.click = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var editor = system.editor;
	var iaction = this.iaction;
	var ito = this.itoAtXY(x, y);
	var it = this._items[ito];
	var redraw = false;
	
	if (ito < 0) {
		/* click on background */
		return;
	}
	if (ito > 0) {
		/* moves item to top */
		this._items.splice(ito, 1);
		this._items.unshift(it);
		ito = 0;
		redraw = true;
	}
	/*  focus the item */
	if (editor.item != it) {
		it.focus(editor);
	}
	var ox = x - it.x;
	if (it.atXY) { /* todo, make this less dirty, move the logic into the item or editor*/
		var ch = it.atXY(ox, y - it.y);
		if (ch) {
			var para = ch.node.anchestor("paragraph");;
			editor.caret.element = ch.node;
			editor.caret.offset = ch.offset + para.getChunkOffset(ch, x - it.x - para.x);
			editor.caret.show();
			redraw = true;
		}
	}
	
	if (redraw) {
		this.redraw();
	}
}

/* stops an operation with the mouse held down */
Space.prototype.dragstop = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var editor = system.editor;
	var iaction = this.iaction;
	switch (iaction.act) {
	case enums.ACT_IDRAG :
		iaction.item.x = x - iaction.sx;
		iaction.item.y = y - iaction.sy;
		iaction.item = null;
		system.setCursor("default");
		this.redraw();
		break;
	case enums.ACT_PAN :
		break;
	case enums.ACT_IRESIZE :
		iaction.com  = null;
		iaction.item = null;
		iaction.six  = null;
		iaction.siy  = null;
		iaction.swi  = null;
		iaction.shi  = null;
		break;
	case enums.ACT_SCROLLY :
		iaction.ssy  = null;
		break;
	default :
		throw new Error("Invalid action in 'Space.dragstop'");
	}
	iaction.act = enums.ACT_NONE;
	iaction.sx   = null;
	iaction.sy   = null;
	return;
}

/* moving during an operation with the mouse held down */
Space.prototype.dragmove = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var iaction = this.iaction;
	switch(iaction.act) {
	case enums.ACT_PAN :
		this.pox += x - iaction.sx;
		this.poy += y - iaction.sy;
		this.redraw();
		return;
	case enums.ACT_IDRAG :
		iaction.item.x = x - iaction.sx;
		iaction.item.y = y - iaction.sy;
		draw = true;
		this.redraw();
		return;
	case enums.ACT_IRESIZE :
	{
		var wi = iaction.swi;
		var hi = iaction.shi;
		var it = iaction.item;
		switch (iaction.com) {
		case "e"  : 
		case "ne" :
		case "se" :
			var wi = iaction.swi + x - iaction.sx;
			if (wi < settings.noteMinSizeX) {
				wi = settings.noteMinSizeX;
			}
			break;
		case "w"  :
		case "nw" :
		case "sw" :	
			var wi = iaction.swi - x + iaction.sx;
			if (wi < settings.noteMinSizeX) {
				wi = settings.noteMinSizeX;
			}
			it.x = iaction.six + iaction.swi - wi;
			break;
		}
		switch (iaction.com) {
		case "s"  : 
		case "sw" :
		case "se" :
			var hi = iaction.shi + y - iaction.sy;
			if (hi < settings.noteMinSizeY) {
				hi = settings.noteMinSizeY;
			}
			break;
		case "n"  : 
		case "nw" :
		case "ne" :
			var hi = iaction.shi - y + iaction.sy;
			if (hi < settings.noteMinSizeY) {
				hi = settings.noteMinSizeY;
			}
			it.y = iaction.siy + iaction.shi - hi;
			break;			
		}
		if (wi != iaction.swi || hi != iaction.shi) {
			it.resize(wi, hi);
			this.redraw();
		}
		var dtreeHeight = it.dtree.getHeight();
		var smaxy = dtreeHeight - (it.height - 2 * it.textBorder);
		if (smaxy > 0 && it.scrolly > smaxy) {
			it.scrolly = smaxy;
			// todo split redraw into reflow and redraw.
			this.redraw();
		}		
		return;
	}
	case enums.ACT_SCROLLY:
	{
		var dy = y - iaction.sy;
		var it = iaction.item;
		var scrollRange = it.height - settings.scrollbarMarginY * 2;
		var dtreeHeight = it.dtree.getHeight();
		var scrollSize  = scrollRange * scrollRange / (dtreeHeight + 2 * it.textBorder);
		var srad = settings.scrollbarRadius;
		if (scrollSize < srad * 2) {
			/* minimum size of scrollbar */
			scrollSize = srad * 2;
		}		
		var sy = iaction.ssy + 
			dy * (dtreeHeight - (it.height - 2 * it.textBorder)) / (scrollRange - scrollSize);
		var smaxy = dtreeHeight - (it.height - 2 * it.textBorder);
		if (sy < 0) {
			sy = 0;
		} else if (sy > smaxy) {
			sy = smaxy;
		}

		it.scrolly = sy;
		this.redraw();
		return true;		
	}
	default :
		throw new Error("unknown action code in Space.dragging");
	}
}

/*	case enums.MENU:
		var cx = system.canvas.getContext("2d");
		drawHexagon(cx, iaction.sx, iaction.sy);
		var bh = iaction.mhover;
		if (cx.isPointInPath(x, y)) {
			iaction.mhover = 0;
		} else {
			iaction.mhover = -1;
		}
		if (bh != iaction.mhover) {
			draw = true;
		}
*/

/* mouse down event */
Space.prototype.mousedown = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	
	var iaction = this.iaction;
	var editor = system.editor;
	/* checks menu */
	/*if (iaction.act == enums.MENU) {
		iaction.act = enums.ACT_NONE;
		iaction.sx = null;
		iaction.sy = null;
		iaction.mhover = null;
		draw = true;
	}*/
		
	var com;
	if (editor.item && (com = checkItemCompass(editor.item, x, y))) {
		/* resizing */
		iaction.act  = enums.ACT_IRESIZE;
		iaction.com  = com;
		iaction.item = editor.item;
		iaction.sx   = x;
		iaction.sy   = y;
		iaction.swi  = editor.item.width;
		iaction.shi  = editor.item.height;
		iaction.six  = editor.item.x;
		iaction.siy  = editor.item.y;
		system.setCursor(com + "-resize");
		return enums.MST_DRAG;
	}
	
	return enums.MST_ATWEEN;
}

/* double click */
/*
Space.prototype.dblclick = function(x, y) {
	var -x = this.pox;
	var -y = this.poy;
	var ito = this.itoAtXY(x, y);
	var iaction = this.iaction;
	if (ito < 0) {
		// on background 
		iaction.act = enums.ACT_MENU;
		iaction.sx = x;
		iaction.sy = y;
		iaction.mhover = 0;
		return false;
	}
	return false;
}*/


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Treenode +++
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Part of a tree-structure.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Treenode(type) {
	this.type   = type;
}

/* appends tnode to list of children */
Treenode.prototype.append = function(tnode) {
	if (tnode.parent) {
		throw new Error("append() on a node already part of a tree");
	}
	tnode.parent = this;
	if (!this.last) {
		this.first = this.last = tnode;
		tnode.prev = tnode.next = null;
	} else {
		this.last.next = tnode;
		tnode.prev = this.last;
		this.last = tnode;
		tnode.next = null;
	}
	tnode.tell = this.listen ? this : this.tell;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* inserts tnode before child bnode */
Treenode.prototype.insertBefore = function(tnode, bnode) {
	if (!bnode) {
		this.append(tnode);
		return
	}
	
	if (tnode.parent) {
		throw new Error("Treenode.append() on a node already part of a tree");
	}
	tnode.parent = this;
	
	if (bnode == this.first) {
		this.first.prev = tnode;
		tnode.next = this.first;
		this.first = tnode;
		tnode.prev = null;
	}
	/* debug check if child */
	if (debugNodes) for(var n=this.first; n != bnode; n = n.next) 
		if (!n) throw new Error("debugNodes");
	
	tnode.next = bnode;
	tnode.prev = bnode.prev;
	bnode.prev.next = tnode;
	bnode.prev = tnode;
	
	tnode.tell = this.listen ? this : this.tell;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* removes child tnode */
Treenode.prototype.remove = function(tnode) {
	/* debug check if child */
	if (debugNodes) for(var n= this.first; n != tnode; n = n.next) 
		if (!n) throw new Error("debugNodes");
	
	if (tnode == this.first) this.first = tnode.next;
	if (tnode == this.last) this.last = tnode.last;
	if (tnode.next) tnode.next.prev = tnode.prev;
	if (tnode.prev) tnode.prev.next = tnode.next;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* returns first anchestor of 'type' */
Treenode.prototype.anchestor = function(type) {
	var n;
	for(n = this; n && n.type != type; n = n.parent);
	if (!n) throw new Error("anchestor not there");
	return n;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 TEXT
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Textnode.prototype = new Treenode;
Textnode.prototype.constructor = Textnode;
function Textnode(text)
{
	Treenode.call(this, "text");
	this._text = text ? text : "";
}

Object.defineProperty(Textnode.prototype, "text", {
	get: function() { 
		return this._text;
	},
	
	set: function(text) {
		if (this._text != text) {
			this._text = text;
			if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
		}
	}
});

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--.                             .
  '|__/ ,-. ,-. ,-. ,-. ,-. ,-. ,-. |-.
  ,|    ,-| |   ,-| | | |   ,-| | | | |
  `'    `-^ '   `-^ `-| '   `-^ |-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~,| ~ ~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
                     `'         '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Paragraph.prototype = new Treenode;
Paragraph.prototype.constructor = Paragraph;
function Paragraph(text)
{
	Treenode.call(this, "paragraph");
	var pcanvas = this._pcanvas = document.createElement("canvas");
	pcanvas.width = pcanvas.height = 0;
	pcanvas.actual == false; // todo move var otherplace
	this.append(new Textnode(text));
	this._width = null;	
	this.x = null;
	this.y = null;
}

/* (re)flows the Paragraph  */
Paragraph.prototype._reflow = function() {
	if (this._flowActual) {
		return;
	}

	/* build position informations */
	this._flowActual = true;
	var pinfo = this._pinfo = [];
	var width = this._width;
	var dtree = this.anchestor("dtree");
	/* canvas is needed for font measurement */
	var cx = this._pcanvas.getContext("2d");
	var textsize = dtree.textsize;
	var x = 0;
	var y = textsize;	
	cx.font = dtree.font;
	var space = cx.measureText(" ").width;
	var pline = 0;
	{
		var l = pinfo[pline] = [];
		l.x = x;
		l.y = y;
	}

	for(var node = this.first; node; node = node.next) {
		var t = node.text;
		var pchunk = 0;
		var reg = !dtree.pre ? (/(\s*\S+)\s?(\s*)/g) : (/(.+)()$/g);
		var stol = true; /* at start of line */
		for(var ca = reg.exec(t); ca != null; ca = reg.exec(t)) {
			/* text is a word plus hard spaces */
			var text = ca[1] + ca[2];
			var w = cx.measureText(text).width;
			if (x + w + space > width) {
				if (!stol) {
					/* soft break */
					x = 0;
					y += Math.round(dtree.textsize * (dtree.pre ? 1 : 1.2));
					pline++;
					{
						var l = pinfo[pline] = [];
						l.x = x;
						l.y = y;
						pchunk = 0;
					}
					stol = true;
				} else {
					/* horizontal overflow */
				}
			}				
			pinfo[pline][pchunk++] = {
				x: x, 
				w: w,
				node: node,
				offset: ca.index, 
				text: text,
			};

			x += w + space;
			stol = false;
		}
	}
	/* returns the logical height (excluding letters bottombox)  */
	this._softHeight = y;
}

/* returns the logical height 
 * (without addition of box below last line base line ofr gpq etc.) */
Object.defineProperty(Paragraph.prototype, "softHeight", {
	get: function() { 
		this._reflow();
		return this._softHeight;
	},
});

Object.defineProperty(Paragraph.prototype, "height", {
	get: function() { 
		var dtree = this.anchestor("dtree");
		return this._softHeight + Math.round(dtree.textsize * 0.27);
	},
	set: function(s) {
		throw new Error("Cannot set paragrph height.");
	}
});


Object.defineProperty(Paragraph.prototype, "width", {
	get: function() { 
		return this._width;
	},
	set: function(width) {
		if (this._width != width) {
			this._width = width;
			this._flowActual = false;
			this._canvasActual = false;
		}
	}
});

/* draws the paragraph in its cache and returns it */
Paragraph.prototype.getCanvas = function(selection) {
	var pcanvas = this._pcanvas;
	if (this._canvasActual) {
		return pcanvas;
	}
	var cx = pcanvas.getContext("2d");
	this._reflow();
	this._canvasActual = true;

	/* selection start and stop */
	/*var sel1line   = null;
	var sel1chunk  = null;
	var sel1offset = null;
	var sel2line   = null;
	var sel2chunk  = null;
	var sel2offset = null;*/
	/*if (selection.active && 
	    selection.element1 == node && 
	    sel1line == null && 
	    ca.index + text.length >= selection.offset1
	) {
		sel1line   = pline;
		sel1chunk  = pchunk;
		sel1offset = selection.offset1 - ca.index;
	}
	if (selection.active && 
	    selection.element2 == node && 
	    sel2line == null && 
	    ca.index + text.length >= selection.offset2
	) {
		sel2line   = pline;
		sel2chunk  = pchunk;
		sel2offset = selection.offset2 - ca.index;
	}*/
			
	/* todo: work out exact height for text below baseline */
	/* set the canvas height */
	var dtree = this.anchestor("dtree");
	{
		var equalHeight = pcanvas.height == this.height;
		var equalWidth  = pcanvas.width  == this._width;
		if (equalHeight && equalWidth) {
			cx.clearRect(0, 0, this._width, this.height);
		} else {
			if (!equalHeight) {
				pcanvas.height = this.height;
			}
			if (!equalWidth) {
				pcanvas.width = this._width;
			}
		}
	}
	cx.font = dtree.font;

	/* draws the selection into the canvas */
	/*if (sel1line != null) {
		var pl1 = pinfo[sel1line];
		var pc1 = pl1[sel1chunk];
		cx.fillStyle = settings.selectionColor;
		var ts = pc1.text.substring(0, sel1offset);
		var cow = cx.measureText(ts).width;
		var x1 = pc1.x + cow;
		cx.fillRect(x1, pl1.y - doc.textsize, 
			width - x1, doc.textsize + Math.round(doc.textsize * 0.27));
	}*/
	
	cx.fillStyle = "black";
	/* draws text into the canvas */
	var pinfo = this._pinfo;
	var plines = pinfo.length;
	for(var il = 0; il < plines; il++) {
		var pl = pinfo[il];
		var plen = pl.length;
		for(var ic = 0; ic < plen; ic++) {
			var pc = pl[ic];
			cx.fillText(pc.text, pc.x, pl.y);
		}
	}
	return pcanvas;
}
	
/* finds the line/chunk by offset */
/* asw ... buffer for answer */
Paragraph.prototype.findByOffset = function(offset, asw) {
	this._reflow();
	var pinfo = this._pinfo;
	var lastl = pinfo[0];
	var lastc = null;
	var plen = pinfo.length;
	for(var pli= 0; pli < plen; pli++) {
		var pl = pinfo[pli];
		var pllen = pl.length;
		for(var pci = 0; pci < pllen; pci++) {
			var pc = pl[pci];
			if (pc.offset == offset) {
				asw.line = pl; asw.chunk = pc;
				return asw;
			}
			if (pc.offset > offset) {
				asw.line = lastl; asw.chunk = lastc;
				return asw;
			}
			lastl = pl;
			lastc = pc;
		}
	}
	asw.line = lastl; asw.chunk = lastc;
	return asw;
}	
	
/* drops the canvas cache (cause something has changed */
Paragraph.prototype.listen = function() {
	this._flowActual   = false;
	this._canvasActual = false;
	if (this.tell) this.tell.listen();
}
	
/* returns chunk at x/y */
Paragraph.prototype.atXY = function(x, y) {
	var pinfo = this._pinfo;
	var plen = pinfo.length;
	var il;
	for (il = 0; il < plen; il++) {
		if (y <= pinfo[il].y) {
			break;
		}
	}
	if (il >= plen) {
		return null;
	}
	var pl = pinfo[il];
	plen = pl.length;
	var plic;
	for (var ic = 0; ic < plen; ic++) {
		plic = pl[ic]; 
		if (x <= plic.x + plic.w) {
			return plic;
		}
	}
	return null;
}
	
/* returns the offset in a chunk of an x coordinate */
Paragraph.prototype.getChunkOffset = function(chunk, dx) {
	dx -= chunk.x;
	var pcanvas = this._pcanvas;
	var cx = pcanvas.getContext("2d");		
	cx.font = this.anchestor("dtree").font;
	var text = chunk.text;
	var tlen = text.length;
	var ox1 = 0;
	var ox2 = 0;
	var i;
	for(i = 0; i < tlen; i++) {
		ox1 = ox2;
		ox2 = cx.measureText(text.substr(0, i)).width;
		if (ox2 > dx) {
			break;
		}
	}
	return dx - ox1 <= ox2 - dx ? i - 1 : i;
}
	
/* join a child node to its next sibling, 
 * or joins this paragraph to its next sibling */
 /* todo, this doesnt belong here */
Paragraph.prototype.joinToNext = function(node, caret) {
	var next = node.next;
	if (next) {
		alert("joinToNext, not yet implemented");
	}
	var nextPara = this.next;
	if (nextPara == null) {
		/* end of document */
		return false;
	}
	node.text = node.text + nextPara.first.text; // todo xxx
	/* todo take over siblings */
	this.parent.remove(nextPara);
	return true;
}
	
/* join a child node to its previous sibling, 
 * or joins this paragraph to its previos sibling */
Paragraph.prototype.joinToPrevious = function(node, caret) {
	var prev = node.prev;
	if (prev) {
		alert("joinToPrevious, not yet implemented");
	}
	var prevPara = this.prev;
	if (prevPara == null) {
		return false;
	}
	var nt = node.text;
	var plc = prevPara.last;
	if (caret) {
		caret.element = plc;
		caret.offset = plc.text.length;
	}
	plc.text = plc.text + nt; // todo xxx
	this.parent.remove(this);
	return true;
}
	
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 DTree
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 A document with nodes in tree structure.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
DTree.prototype = new Treenode;
DTree.prototype.constructor = DTree;
function DTree() {
	Treenode.call(this, "dtree");
	this.textsize = 13;
	this.font = this.textsize + 'px Verdana,Geneva,Kalimati,sans-serif';
}
		
/* returns the chunk at x,y */
DTree.prototype.atXY = function(x, y) { //xxx
	var p = this.first;
	while (p && y > p.y + p.softHeight) {
		p = p.next;
	}
	if (p == null) {
		return null;
	}
	return p.atXY(x - p.x, y - p.y);
}

/* draws the content in a buffer canvas */
/* acanvas  ... canvas to draw upon */
/* todo rename */
DTree.prototype.drawCanvas = function(acanvas, offsetX, offsetY, width, scrolly, selection) {
	var cx = acanvas.getContext("2d");
	var y = offsetY;
	var pi = 0;
	var h = 0;
	var parasep = this.pre ? 0 : this.textsize;

	/* calculate height
	 * paragraph is going to cache the canvas
	 * every paragraph */
	for(var para = this.first; para; para = para.next) {
		if (h > 0) {
			h += parasep;
		}
		h += para.softHeight;
	}

	for(var para = this.first; para; para = para.next) {
		para.width = width; /* todo */
		var pcanvas = para.getCanvas(selection);
		para.x = offsetX;
		para.y = y;
		cx.drawImage(pcanvas, offsetX, y - scrolly);
		y += para.softHeight + parasep;
	}
}

/* returns the height of the drawn document */
DTree.prototype.getHeight = function() {
	var h = 0;
	var parasep = this.pre ? 0 : this.textsize;
	var first = true;
	for(var para = this.first; para; para = para.next) {
		if (!first) {
			h += parasep;
		} else {
			first = false;
		}
		h += para.softHeight;
	}
	return h;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,-_/ .
 '  | |- ,-. ,-,-.
 .^ | |  |-' | | |
 `--' `' `-' ' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 
 Something on a canvas.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Item(width, height) {
/* todo, not used! */
   this.width  = width;
   this.height = height;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
,-,-.       .      
` | |   ,-. |- ,-. 
  | |-. | | |  |-' 
 ,' `-' `-' `' `-' 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 An item with text and a scrollbar.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Note(width, height) {
	this.bcanvas = document.createElement("canvas");
	this.textBorder = settings.noteTextBorder;
	this.bcanvas.actual = false;
	
	this.width  = width;
	this.height = height;
	this._scrollx = -8833;
	this._scrolly = -8833;
	this.bcanvas.width  = width; /* need to set it so early? */
	this.bcanvas.height = height;
	this.dtree = new DTree();
	this.dtree.tell = this;
}

/* returns the chunk at x, y */
Note.prototype.atXY = function(x, y) {
	if (this._scrolly > 0) {
		y += this._scrolly;
	}
	if (x < this.textBorder || y < this.textBorder) {
		return null;
	}
	return this.dtree.atXY(x, y);
}

/* drops the cached canvas */
Note.prototype.listen = function() {
	this.bcanvas.actual = false;
}
	
/* resizes the note */
Note.prototype.resize = function(width, height) {
	if (this.width == width && this.height == height) {
		return;
	}
	var bcanvas = this.bcanvas;
	this.width  = bcanvas.width  = width; /* todo, not yet do sizing */
	this.height = bcanvas.height = height;
	bcanvas.actual = false;
}

Object.defineProperty(Note.prototype, "scrolly", {
	get: function() { 
		return this._scrolly;
	},
	
	set: function(sy) {
		if (sy < 0 && sy != -8833) {
			throw new Error("Invalid scrolly position");
		}
		if (this._scrolly != sy) {
			this._scrolly = sy;
			this.bcanvas.actual = false;
		}
	}
});

/* draws a bevel */
function Note_bevel(cx, x, y, w, h, border, radius) {
	var x1 = x + border;
	var y1 = y + border;
	var x2 = x + w - border;
	var y2 = y + h - border;
			
	cx.moveTo(x1 + radius, y1);
	cx.arc(x2 - radius, y1 + radius, radius, -Math.PI / 2, 0, false);
	cx.arc(x2 - radius, y2 - radius, radius, 0, Math.PI / 2, false);
	cx.arc(x1 + radius, y2 - radius, radius, Math.PI / 2, Math.PI, false);
	cx.arc(x1 + radius, y1 + radius, radius, Math.PI, -Math.PI / 2, false);
}
	
/* gets the canvas buffer for this item
 * returns null if with scrollbar and all doc fits in 
 * or if with without and doc doesnt fit
 */
Note.prototype._getCanvasImpl = function(selection) {
	var bcanvas = this.bcanvas;
	var dtree = this.dtree;
	var cx = bcanvas.getContext("2d");
	if (bcanvas.actual) {
		/* buffer hit */
		return bcanvas;
	}
	// todo create sizing here;

	/* draws the note */
	cx.clearRect(0, 0, bcanvas.width, bcanvas.height);	
	Note_bevel(cx, 0, 0, this.width, this.height, 2.5, 3);
	var grad = cx.createLinearGradient(0, 0, this.width / 10, this.height);			
	grad.addColorStop(0, settings.noteBackground1);
	grad.addColorStop(1, settings.noteBackground2);
	cx.fillStyle = grad;
	cx.fill();
	cx.fillStyle = "#000000";

	/* draws text */
	var sy = this._scrolly;
	var innerWidth = this.width  - 2 * this.textBorder - 
		(sy >= 0 ? settings.scrollbarRadius * 2 : 0);
	var innerHeight = this.height - 2 * this.textBorder;
	dtree.drawCanvas(bcanvas, 
		this.textBorder, this.textBorder, innerWidth, 
		sy < 0 ? 0 : Math.round(sy),
		selection
	);
	
	var dtreeHeight = dtree.getHeight();
	if (sy < 0 && dtreeHeight > innerHeight) {
		/* should use a scrollbar */
		return null;
	}

	if (sy >= 0) {
		if (dtreeHeight <= innerHeight) {
			/* should not use a scrollbar */
			return null;
		}

		/* draws the vertical scroll bar */
		cx.fillStyle   = settings.scrollbarFillStyle;
		cx.strokeStyle = settings.scrollbarStrokeStyle;
		cx.lineWidth   = settings.scrollbarLineWidth;
		
		var scrollRange = this.height - settings.scrollbarMarginY * 2;
		var srad       = settings.scrollbarRadius;
		var scrollSize  = scrollRange * scrollRange / (dtreeHeight + 2 * this.textBorder);
		var spx = this.width - settings.scrollbarMarginX - srad;
		if (scrollSize < srad * 2) {
			/* minimum size of scrollbar */
			scrollSize = srad * 2;
		}
						
		var spy = settings.scrollbarMarginY + 
			sy / (dtreeHeight - (this.height - 2 * this.textBorder)) * (scrollRange - scrollSize);
			sy / (dtreeHeight - (this.height - 2 * this.textBorder)) * (scrollRange - scrollSize);
		
		cx.beginPath();
		cx.arc(spx, spy + srad, srad, Math.PI, 0, false);
		cx.arc(spx, spy + scrollSize - srad, srad, 0, Math.PI, false);
		cx.closePath();
		cx.stroke();
		cx.fill();
	}

	/* draws the border */
	cx.beginPath(); 
	cx.lineWidth = settings.noteInnerBorderWidth;
	cx.lineWidth = "2";
	cx.strokeStyle = settings.noteInnerBorderColor;
	cx.strokeStyle = "#ffbc57";
	Note_bevel(cx, 0, 0, this.width, this.height, 1.5, 4);
	cx.stroke(); cx.beginPath(); cx.closePath();
	cx.lineWidth = "1";
	cx.strokeStyle = "#000000";
	Note_bevel(cx, 0, 0, this.width, this.height, 0.5, 5);
	cx.stroke(); cx.beginPath(); cx.closePath();
	cx.restore();		
	bcanvas.actual = true;			
	return bcanvas;	
}
	
/* item gets focus */
Note.prototype.focus = function(editor) {
	editor.focus(this);
	this.bcanvas.actual = false;
	editor.caret.show();
}
	
/* gets the canvas buffer for this item */
Note.prototype.getCanvas = function(selection) {
	var asw = this._getCanvasImpl(selection);
	if (asw == null) {
		if (this._scrolly >= 0) {
			this._scrolly = -8833;
		} else {
			this._scrolly = 0;		
		}
		asw = this._getCanvasImpl(selection);
	}
	if (asw == null) {
		throw new Error("note doesnt fit with and without scrollbar.");
	}
	return asw;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
,.   ,.       .          ,---.              .
`|  / ,-. ,-. |- ,-. ,-. |  -'  ,-. ,-. ,-. |-.
 | /  |-' |   |  | | |   |  ,-' |   ,-| | | | |
 `'   `-' `-' `' `-' '   `---|  '   `-^ |-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ,-.|~ ~ ~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Something that draws     `-+' vectors  '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function VectorGraph(width, height, doc)
{
	this.bcanvas = document.createElement("canvas");
	this.width  = bcanvas.width  =  width;
	this.height = bcanvas.height = height;
	this.doc = doc;
}

/* gets the canvas buffer for this item */
/* if caret != null draws the caret into the canvas */
VectorGraph.prototype.getCanvas = function(selection) {
	var cx = this.bcanvas.getContext("2d");
	cx.beginPath();
	cx.clearRect(0, 0, bcanvas.width, bcanvas.height);
	draw = "";
	for(var para = doc.getFirstPara(); para; para = para.next) {
		var cmd = para.first.text;
		draw += cmd + "\n";
		var reg = /(\S+)\s*/g;
		var cc = [];
		var ci = 0;
		for(var ca = reg.exec(cmd); ca != null; ca = reg.exec(cmd)) {
			/* text is a word plus hard spaces */
			cc[ci++] = ca[1]; 
		}
		switch (cc[0]) {
		case 'A' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			var a5 = parseFloat(cc[5]);
			var a6 = parseFloat(cc[6]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" ||
			    typeof(a5) != "number" ||
			    typeof(a6) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.arc(a1, a2, a3, a4 * Math.PI / 4, a5 * Math.PI / 4, a6 > 0 ? true : false);
			break;
		case '.' :			
			cx.closePath();
			break;
			case 'F' :			
			cx.fill();
			cx.beginPath();
			break;
		case 'B' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			var a5 = parseFloat(cc[5]);
			var a6 = parseFloat(cc[6]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" ||
			    typeof(a5) != "number" ||
			    typeof(a6) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.bezierCurveTo(a1, a2, a3, a4, a5, a6);
			break;
		case 'Q' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" 
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.quadraticCurveTo(a1, a2, a3, a4, a5, a6);
			break;
		case 'M' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.moveTo(a1, a2);
			break;
		case 'L' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.lineTo(a1, a2);
			break;
		case 'S' :
			cx.stroke();
			cx.beginPath();
			break;
		case 'c' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.strokeStyle = "rgb(" + a1 + "," + a2 + "," + a3 +")";
			break;
		case 'C' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.fillStyle = "rgb(" + a1 + "," + a2 + "," + a3 +")";
			break;
		case 'W' :
			var a1 = parseFloat(cc[1]);
			if (typeof(a1) != "number") {
				//msg("Arguments not numbers: " + cmd);
				break;
			}				
			cx.lineWidth = a1;
		case '' :
			break;
		default :
			//msg("Unknown command: " + cmd);
			break;
		}
	}			
	return bcanvas;
}
	
/* item gets focus */
VectorGraph.prototype.focus = function(editor) {
	return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,.   ,   ,.       .
 `|  /|  / . ,-. ,-| ,-. . , ,
  | / | /  | | | | | | | |/|/
  `'  `'   ' ' ' `-^ `-' ' '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
window.onload = function() {
	system.init();
}

//]]></script>
</head>
<body style="margin: 0; overflow: hidden;">
<textarea id="input" style="position: absolute; top:-200px;"></textarea>
<canvas id="canvas">
  You need a browser that supports HTML5 Canvas elements!
</canvas>
<!--div id="output" style="white-space: pre; font-family: monospace"></div-->
<br/><br/>
</body>
</html>