<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8"/>
<title>Meshcraft</title>
<link rel="shortcut icon" href="/favicon.ico" />

	
<!--                                                     _.._
                                                      .-'_.._''.
 __  __   ___       _....._              .          .' .'     '.\
|  |/  `.'   `.   .Â´       '.          .'|         / .'                                _.._
|   .-.  .-.   ' /   .-'"'.  \        (  |        . '            .-,.-~.              .' .._|    .|
|  |  |  |  |  |/   /______\  |        | |        | |            |  .-. |    __      | '      .' |_
|  |  |  |  |  ||   __________|    _   | | .'''-. | |            | |  | | .:-`.'.  __| |__  .'     |
|  |  |  |  |  |\  (          '  .' |  | |/.'''. \. '            | |  | |/ |   \ ||__   __|'-..  .-'
|  |  |  |  |  | \  '-.___..-~. .   | /|  /    | | \ '.         .| |  '- `" __ | |   | |      |  |
|__|  |__|  |__|  `         .'.'.'| |//| |     | |  '. `.____.-'/| |      .'.''| |   | |      |  |
                   `'-.....-.'.'.-'  / | |     | |    `-._____ / | |     / /   | |_  | |      |  '.'
                                 \_.'  | '.    | '.           `  |_|     \ \._,\ '/  | |      |   /
                                       '___'   '___'                      `~~'  `"   |_|      `'--> 

<script type="text/javascript">//<![CDATA[

"use strict";

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.---.     .  .
\___  ,-. |- |- . ,-. ,-. ,-.
    \ |-' |  |  | | | | | `-.
`---' `-' `' `' ' ' ' `-| `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~,| ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
                       `'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* if true catch all errors and report to user,    
 * if false let them pass through to e.g. firebug. */
var enableCatcher = false;
var debugNodes = true;

var settings = {

	defaultFont : "Verdana,Geneva,Kalimati,sans-serif",

	/* milliseconds after mouse down, dragging starts */
	dragtime : 400,
	/* pixels after mouse down and move, dragging starts */
	dragbox  : 10,
	
	/* minimum size for notes */
	noteMinSizeX : 40,
	noteMinSizeY : 40,
	
	/* note style */
	noteTextBorder : 10,
	noteInnerBorderWidth : 2,
	noteInnerBorderColor : "#ffbc57",
	noteOuterBorderWidth : 1,
	noteOuterBorderColor : "black",
	noteBackground1 : "rgba(255, 255, 248, 0.935)",
	noteBackground2 : "rgba(255, 255, 160, 0.935)",
	
	newNoteWidth : 200,
	newNoteHeight : 100,
	
	/* float menu style */
	floatMenuInnerBorderWidth : 2,
	floatMenuInnerBorderColor : "#ffbc57",
	floatMenuOuterBorderWidth : 1,
	floatMenuOuterBorderColor : "black",
	floatMenuBackground1 : "rgba(255, 255, 168, 0.935)",
	floatMenuBackground2 : "rgba(255, 255, 248, 0.935)",
	floatMenuFillStyle : "#ffbc57",
	
	/* selection */
	//selectionColor : "#8080ff",
	selectionColor  : "rgba(243, 203, 255, 0.9)",
	selectionStroke : "rgb (243, 183, 253)",
	
	/* scrollbar */
	scrollbarForm        : "hexagonh",  // 'square', 'round', 'hexagonh' or 'hexagonv'
	scrollbarFillStyle   : "#ffbc57",
	scrollbarStrokeStyle : "#dd9a34",
	scrollbarLineWidth   : 2,
	scrollbarRadius      : 4,
	scrollbarMarginX     : 7,
	scrollbarMarginY     : 5,
	
	/* size of resize handles */
	handleSize : 10,
	handleDistance : 0,
	handleColor1 : "rgb(125,120,32)",
	handleWidth1 : 3,
	handleColor2 : "rgb(255,180,90)",
	handleWidth2 : 1,
	
	/* blink speed of the caret */
	caretBlinkSpeed : 530,	
};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--.      .
 ' |   \ ,-. |-. . . ,-.
 , |   / |-' | | | | | |
 `-^--'  `-' ^-' `-^ `-|
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ,|~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~                       
 Prints out messages  `' and objects on the console.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function debug() {
	if (!console) return;
	var l = "";
	for(var i = 0; i < arguments.length; i++) {
		if (i > 0) { 
			l += " ";
		}
		var a = arguments[i];
		if (a == null) {
			l += "|null|";
		} else if (a.substring || typeof(a) != "object") {
			l += a;
		} else {
			l += "{";
			var first = true;
			var p;
			for (p in a) {
				if (!first) {
					l += ", ";
				} else {
					first = false;
				}
				switch (typeof(a[p])) {
				case "function" : 
					l += p + " : function";
					break;
				default:
					l += p  + " : " + a[p];
					break;
				}
			}
			l += "}";
		}
	}
	console.log(l);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.-,--.
 `\__  ,-. . . ,-,-. ,-.
  /    | | | | | | | `-.
 '`--' ' ' `-^ ' ' ' `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
var enums = {
	/* Mouse state */
	MST_NONE   : 0, /* button is up */
	MST_ATWEEN : 1, /* just came down, unsure if click or drag */
	MST_DRAG   : 2, /* mouse is dragging */

	/* interface action active */
	ACT_NONE    : 0,
	ACT_PAN     : 1,
	ACT_IDRAG   : 2,
	ACT_IRESIZE : 3,
	ACT_SCROLLY : 4,
	ACT_FMENU   : 5,
};


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ,                       
  )   ,-. ,-. ,-. ,-. . . 
 /    |-' | | ,-| |   | | 
 `--' `-' `-| `-^ `-' `-| 
           ,|          /| 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

if (!Object.defineProperty) {
	Object.defineProperty = function(obj, label, funcs) {
		if (funcs.get) {
			obj.__defineGetter__(label, funcs.get);
		}
		if (funcs.set) {
			obj.__defineSetter__(label, funcs.set);
		}
	}
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,-,-,-.
 `,| | |   ,-. ,-. ,-. . . ,-. ,-.
   | ; | . |-' ,-| `-. | | |   |-'
   '   `-' `-' `-^ `-' `-^ '   `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Marks a position in an element of an item.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
var Measure = {
	init : function() {
		Measure._canvas = document.createElement("canvas");
		Measure._cx = this._canvas.getContext("2d");
	},
	
	width : function(text) {
		return Measure._cx.measureText(text).width;
	}
}

Object.defineProperty(Measure, "font", {
	get: function() { return Measure._cx.font; },
	set: function(font) { Measure._cx.font = font; }
});

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ,-,-,-.           .
 `,| | |   ,-. ,-. | , ,-. ,-.
   | ; | . ,-| |   |<  |-' |
   '   `-' `-^ '   ' ` `-' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Marks a position in an element of an item.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Marker() {
	this._item = null;
	this._element = null;
	this._offset = 0;
	this._pli = null;
	this._cli = null;
}

Object.defineProperty(Marker.prototype, "item", {
	/* todo needed? */
	get: function() { return this._item; },
	set: function(it) { throw new Error("use set()"); }
});

Object.defineProperty(Marker.prototype, "element", {
	get: function() { return this._element; },
	set: function(e) { throw new Error("use set()"); }
});

Object.defineProperty(Marker.prototype, "offset", {
	get: function() { return this._offset; },
	set: function(o) { this._offset = o; }
});

/* "overloaded" 3-timed
 * set(marker)
 * set(element, offset)
 * set(item, element, offset)
 */
Marker.prototype.set = function(a1, a2, a3) {
	switch (arguments.length) {
	case 1 :
		this._item    = a1._item; 
		this._element = a1._element;
		this._offset  = a1._offset;
		break;
	case 2 :
		this._element = a1;
		this._offset  = a2;
		break;
	case 3 :
		this._item    = a1;
		this._element = a2;
		this._offset  = a3;
		break;
	default :
		throw new Error("wrong # of arguments");
		break;
	}
}

/* returns chunk at x/y */
Marker.prototype._getPinfoAtXY = function(flowbox, x, y) {
	var pinfo = flowbox.pinfo;
	var plen = pinfo.length;
	var li;
	for (li = 0; li < plen; li++) {
		if (y <= pinfo[li].y) {
			break;
		}
	}
	if (li >= plen) {
		li--; /* got to last line if overflow */
	}
	this._pli = li;
	var l = pinfo[li];
	var llen = l.length;
	var c;
	for (var ci = 0; ci < llen; ci++) {
		c = l[ci]; 
		if (x <= c.x + c.w) {
			this._pci = ci;
			return pinfo;
		}
	}
	/* set to last chunk if overflow */
	this._pci = llen - 1;
	return pinfo;
}

/* Sets .x and .y to coordinates of actual position, relative to dtree */
Marker.prototype.getXY = function() {
	/* todo cache position */
	var dtree = this._item.dtree;
	Measure.font = dtree.font;
	var e = this._element;
	var t = e.text;
	var p = e.anchestor("paragraph");
	var pinfo = this.getPinfo();
	var l = pinfo[this._pli];
	var c = l[this._pci];
	this.x = p.x + (c ? c.x + Measure.width(t.substring(c.offset, this._offset)) : l.x);
	this.y = p.y + l.y - dtree.textsize; /* todo baseline? */
}
	
/* sets the marker to position closest to x, y from flowbox(para) */
Marker.prototype.setFromXY = function(flowbox, x, y) {
	if (flowbox.type != "paragraph") { throw new Error("invalid flowbox."); }
	var pinfo = this._getPinfoAtXY(flowbox, x, y);
	var l = pinfo[this._pli];
	var c = l[this._pci]; // x,y is in this chunk
	
	if (!c) {
		/* todo? */
		this._element = flowbox.first;
		this._offset = 0;
		return;
	}
	var dx   = x - c.x;
	Measure.font = flowbox.anchestor("dtree").font;
	var t    = c.text;
	var tlen = t.length;
	
	var x1 = 0, x2 = 0;
	var o;
	for(o = 0; o < tlen; o++) {
		x1 = x2;
		x2 = Measure.width(t.substr(0, o));
		if (x2 > dx) {
			break;
		}
	}
	if (dx - x1 <= x2 - dx) o--;
	this._element = c.node;
	this._offset = c.offset + o;
}

/* sets the this.pline and this.pchunk according to the chunk 
 * the marker is in */
Marker.prototype.getPinfo = function() {
	var te = this._element;
	var to = this._offset;
	var para  = te.anchestor("paragraph");
	var pinfo = para.pinfo;
	var bli =  0; /* buffer for line count */
	var bci = -1; /* buffer for chunk count */
	var plen  = pinfo.length;
	for(var li= 0; li < plen; li++) {
		var l = pinfo[li];
		var llen = l.length;
		for(var ci = 0; ci < llen; ci++) {
			var c = l[ci];
			if (c.offset == to) {
				this._pli = li; this._pci = ci;
				return pinfo;
			}
			if (c.offset > to) {
				this._pli = bli; this._pci = bci;
				return pinfo;
			}
			bli = li; bci = ci;
		}
	}
	this._pli = bli; this._pci = bci;
	return pinfo;
}

/* moves the marker a line up (dir == true) or down */
/* returns true if moved */
Marker.prototype.moveUpDown = function(dir) {
	var e  = this._element;
	var o  = this._offset;
	Measure.font = e.anchestor("dtree").font;
	var p  = e.anchestor("paragraph");
	var pinfo = this.getPinfo();
	var li = this._pli;
	var ci = this._pci;
	var l = pinfo[li];
	var c = l[ci];
	var x = (c ? c.x : l.x) + Measure.width(c.text.substr(0, o - c.offset));
	if (dir) {
		if (li == 0) {
			p = p.prev;
			if (!p) return false;
			pinfo = p.pinfo;
			l = pinfo[pinfo.length - 1];
		} else {
			l = pinfo[li - 1];
		}
	} else {
		if (li + 1 >= pinfo.length) {
			p = p.next;
			if (!p) return false;
			pinfo = p.pinfo;
			l = pinfo[0];
		} else {
			l = pinfo[li + 1];
		}	
	}
	var llen = l.length;
	for(ci = 0; ci < llen && x > l[ci].x + l[ci].w; ci++);
	if (ci >= llen) {
		c = l[llen - 1];
		this._element = c.node;
		this._offset  = c.offset + c.text.length;
		return true;
	}
	c = l[ci];
	
	var t = c.text;
	var tlen = t.length;
	var x1 = 0, x2 = 0;
	var dx = x - c.x;
	var o;
	for(o = 0; o < tlen; o++) {
		x1 = x2;
		x2 = Measure.width(t.substr(0, o));
		if (x2 > dx) {
			break;
		}
	}
	if (dx - x1 <= x2 - dx) o--;	
	this._element = c.node;
	this._offset  = c.offset + o;
	return true;
}

/* moves the marker a line left (dir == true) or right */
/* returns true if moved */
Marker.prototype.moveLeftRight = function(dir) {
	if (dir) {
		if (this._offset > 0) {
			this._offset--;
		} else {
			var pev = this._element.parent.prev;
			if (!pev) {
				return false;
			}
			var e = this._element = pev.last;
			this._offset = e.text.length;
		}
	} else {
		var t = this._element.text;
		if (this._offset < t.length) {
			this._offset++;
		} else {
			var pnext = this._element.parent.next;
			if (!pnext) {
				return false;
			}
			this._element = pnext.first;
			this._offset = 0;
		}
	}
	return true;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ,--.             .  
 | `-' ,-. ,-. ,-. |- 
 |   . ,-| |   |-' |  
 `--'  `-^ '   `-' `' 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Caret.prototype = new Marker;
Caret.prototype.constructor = Caret;
function Caret() {
	Marker.call(this);
	
	/* true if visible */
	this.shown = false;
	/* true when just blinked away */
	this.blink = false;	
}
	
/* shows the caret or resets the blink timer if already shown */
Caret.prototype.show = function() {
	this.shown = true;
	this.blink = false;
	System.startBlinker();
}
	
/* hides the caret */
Caret.prototype.hide = function() {
	this.shown = false;
	System.stopBlinker();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .---.     .          .
 \___  ,-. |  ,-. ,-. |- . ,-. ,-.
     \ |-' |  |-' |   |  | | | | |
 `---' `-' `' `-' `-' `' ' `-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Selection() {
	this.active = false;
	this.begin = new Marker();
	this.end   = new Marker();
}	

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.-,--.   .   .
 `\__  ,-| . |- ,-. ,-.
  /    | | | |  | | |
 '`--' `-^ ' `' `-' '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Editor() {
	this.caret     = new Caret();
	this.selection = new Selection();
	this.item      = null;
}

/* draws or erases the caret */
Editor.prototype.updateCaret = function() {
	var cx = System.canvas.getContext("2d");
	var caret = this.caret;
	if (caret.save) {
		/* erase the old caret */
		cx.putImageData(caret.save, caret.sx - 1, caret.sy - 1);
		caret.save = null;
	} 
		
	if (caret.shown && !caret.blink) {
		caret.getXY();
		var it = caret.item;
		var sy = it.scrolly;
		var x = System.space.pox + it.x + caret.x;
		var y = System.space.poy + it.y + caret.y - (sy > 0 ? sy : 0);
		var th = Math.round(it.dtree.textsize * 1.2);
		
		caret.save = cx.getImageData(
			(caret.sx = x) - 1, 
			(caret.sy = y) - 1, 
			caret.sh = 3, 
			caret.sw = th + 1);
		cx.fillStyle = "black";
		cx.fillRect(x, y, 1, th);
	}
}	
	
/* got a special key */
/* returns redraw code telling if the element needs to be redrawn. */
Editor.prototype.specialKey = function(keycode, shiftKey) {
	if (!this.item) {
		return false;
	}
	var refresh = false;
	var redraw = false;
	var caret  = this.caret;
	var select = this.selection;			

	if (!shiftKey && select.active) {
		select.active = false;
		this.item.listen(); /* make not actual */
		redraw = true;
	} else if (shiftKey && !select.active) {
		switch(keycode) {
		case 35 : // end
		case 36 : // pos1
		case 37 : // left
		case 38 : // up
		case 39 : // right
		case 40 : // down	
			select.begin.set(caret);
		}
	}

	
	switch(keycode) {
	case  8 : // backspace
	{
		var co = caret.offset;
		var ce = caret.element;
		if (co > 0) {
			var t = ce.text;
			ce.text = t.substring(0, co - 1) + t.substring(co, t.length);
			caret.offset--;
			redraw = true;
		} else {
			var para = ce.anchestor("paragraph");
			redraw = para.joinToPrevious(ce, caret);
		}
		break;
	}
	case 13 : // return
	{
		var ce    = caret.element;
		var co    = caret.offset;			
		var ct    = ce.text;
		/* todo multi node ability */
		var opara = ce.anchestor("paragraph");
			
		ce.text = ct.substring(0, co);
		var npara = new Paragraph(ct.substring(co, ct.length));
		opara.parent.insertBefore(npara, opara.next);
		caret.set(npara.first, 0);
		redraw = true;
		break;
	}
	case 35 : // end
	{
		caret.offset = caret.element.text.length;
		refresh = true;
		break;
	}
	case 36 : // pos1
	{
		caret.offset = 0;
		refresh = true;
		break;
	}
	case 37 : // left
	{
		var change = caret.moveLeftRight(true);
		refresh = change;
		break;
	}
	case 38 : // up
		refresh = caret.moveUpDown(true);
		break;
	case 39 : // right
	{	
		refresh = caret.moveLeftRight(false);		
		break;
	}
	case 40 : // down
		refresh = caret.moveUpDown(false);
		break;
	case 46 : // del
	{
		var co = caret.offset;
		var ce = caret.element;
		var ct = ce.text;
		if (co < ct.length) {
			ce.text = ct.substring(0, co) + ct.substring(co + 1, ct.length);
			redraw = true;
		} else {
			var para = ce.anchestor("paragraph");
			redraw = para.joinToNext(ce, caret);
		}
		break;
	}
	default :
		break;
	}


	if (shiftKey && refresh) {
		switch(keycode) {
		case 35 : // end
		case 36 : // pos1
		case 37 : // left
		case 38 : // up
		case 39 : // right
		case 40 : // down	
			select.active = true;
			select.end.set(caret);
			this.item.listen(); /* make not actual */
			redraw = true;
		}
	}
	
	
	if (refresh || redraw) {
		caret.show();
	}
	if (refresh && !redraw) {
		this.updateCaret();
	}
	return redraw;
}

/* blinks the caret away or into visiblity */
Editor.prototype.blink = function() {
	if (this.caret.shown) {
		this.caret.blink = !this.caret.blink;
		this.updateCaret();			
	}
}
	
/* got character input from user */
/* returns redraw needs */
Editor.prototype.input = function(text) {
	if (!this.item) {
		return false;
	}
	var caret = this.caret;
	for(var ci = 0; ci < text.length; ci++) {
		var ch = text[ci];
		var ce = caret.element;
		var co = caret.offset;
		var ct = ce.text;
		ce.text = ct.substring(0, co) + ch + ct.substring(co, ct.length);
		this.caret.offset++;
	}
	return true;
}
				
/* editor got systemFocus */
Editor.prototype.systemFocus = function() {
	if (this.item) {
		this.caret.show();
		this.updateCaret();
	}
}

/* editor got systemFocus */
Editor.prototype.systemBlur = function() {
	this.caret.hide();
}

/* editor focuses one item */
Editor.prototype.focus = function(item) {
	this.item = item;
	var caret = this.caret;
	caret.set(item, item.dtree.first.first, 0);
}
		
/* editor disconnects */
Editor.prototype.blur = function() {
	this.item = null;
	this.caret.hide();
	this.caret.set(null, null, null);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .---.         .
 \___  . . ,-. |- ,-. ,-,-.
     \ | | `-. |  |-' | | |
 `---' `-| `-' `' `-' ' ' '
~ ~ ~ ~ /|~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  Base-`-'-system for Meshcraft. 
  All system events arrive here.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
var System = { 

/* Catches all errors for a function */
makeCatcher : function(that, fun) {
	return function() {
		"use strict";
		if (enableCatcher) {
			try {
				fun.apply(that, arguments);
			} catch(err) {
				alert("Internal failure, " + err.name + ": " + err.message + "\n\n" + 
				      "file: " + err.fileName + "\n" + 
					  "line: " + err.lineNumber + "\n" + 
					  "stack: " + err.stack);
			}
		} else {
			fun.apply(that, arguments);
		}
	};
},

init : function() {
	System.makeCatcher(System, System._init)();
},

_init : function() {
	if (this != System) {
		throw new Error("System has wrong this pointer");
	}
	var canvas = this.canvas = document.getElementById("canvas");
	canvas.width  = window.innerWidth - 1;
	canvas.height = window.innerHeight - 1;
	var cx = canvas.getContext("2d");
	Measure.init();
	
	/* the space that currently is displayed */
	this.space = null;

	/* if true use browser supported setCapture() call
	 * if false work around */
	var useCapture = canvas.setCapture != null;

	/* mouse state */
	var mst = enums.MST_NONE;
	/* position the mouse went down to atween state */
	var msx = null;
	var msy = null;
	/* latest mouse position seen in atween state */
	var mmx = null;
	var mmy = null;
	/* timer for atween state */
	var atweenTimer = null;

	var editor = this.editor = new Editor();
	
	/* hidden input that forwards all events */
	var hiddenInput = document.getElementById("input");
	
	/* remembers last SpecialKey pressed, to hinder double events.
	 * Opera is behaving stupid here. */
	var lastSpecialKey = -1;
	
	/* a special key is pressed */
	function specialKey(keyCode, shiftKey) {
		switch(keyCode) {
		case  8 : // backspace
		case 13 : // return
		case 35 : // end
		case 36 : // pos1
		case 37 : // left
		case 38 : // up
		case 39 : // right
		case 40 : // down
		case 46 : // del
			this.space.specialKey(keyCode, shiftKey);
			return false;
		default : 
			return true;
		}
	}

	/* captures all mouseevents event beyond the canvas (for dragging) */ 
	function captureEvents() {
		if (useCapture) {
			canvas.setCapture(canvas);
		} else {
			document.onmouseup = onmouseup;
			document.onmousemove = onmousemove;
		}
	}
	
	/* stops capturing all mouseevents */
	function releaseEvents() {
		if (useCapture) {
			canvas.releaseCapture(canvas);
		} else {
			document.onmouseup = null;
			document.onmousemove = null;
		}
	}

	/*-- Functions the browser calls --*/
	
	/* tests if the hidden input field got data */
	function testinput() {
		var text = hiddenInput.value;
		if (text == "") {
			return;
		}
		hiddenInput.value = "";
		System.space.input(text);
	}
	
	/* do a blink */
	function blink() {
		/* hackish, also look into the hidden input field, 
		 * maybe the user pasted something using the browser menu. */
		testinput();
		editor.blink();
	}
	
	/* key down in hidden input field */
	function onkeydown(event) {
		var pass = specialKey.call(this, lastSpecialKey = event.keyCode, event.shiftKey);
		if (!pass) event.preventDefault();
	}
		
	/* hidden input key press */
	function onkeypress(event) {
		var ew = event.which;
		var ek = event.keyCode;
		if (((ek > 0 && ek < 32) || ew == 0) && lastSpecialKey != ek) {
			lastSpecialKey = -1;
			return specialKey(ek, event.shiftKey);
		}
		lastSpecialKey = -1;
		testinput();
		setTimeout("System.ontestinput();", 0);
		return true;
	}

	/* hidden input key up */
	function onkeyup(event) {
		testinput();
		return true;
	}
	
	/* hidden input lost focus */
	function onblur(event) {
		this.space.systemBlur();
	}
	
	/* hidden input got focus */
	function onfocus(event) {
		this.space.systemFocus();
	}
		
	/* view window resized */
	function onresize(event) {
		/* todo debouncing */
		canvas.width  = window.innerWidth - 1;
		canvas.height = window.innerHeight - 1;	
		this.space && this.space.redraw();
	}
	
	/* mouse move event */
	function onmousemove(event) {
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;

		switch(mst) {
		case enums.MST_NONE :
			this.space.mousehover(x, y);
			return true;
		case enums.MST_ATWEEN :
		{
			var dragbox = settings.dragbox;
			if ((Math.abs(x - msx) > dragbox) || (Math.abs(y - msy) > dragbox)) {
				/* moved out of dragbox -> start dragging */
				clearTimeout(atweenTimer);
				atweenTimer = null;
				mst = enums.MST_DRAG;
				this.space.dragstart(msx, msy);
				if (x != msx || y != msy) {
					this.space.dragmove(x, y);
				}
				captureEvents();
			} else {
				/* saves position for possible atween timeout */
				mmx = x;
				mmy = y;
			}
			return true;
		}
		case enums.MST_DRAG :
			this.space.dragmove(x, y);
			return true;
		default :
			throw new Error("invalid mst");
		}
	}
	
	/* mouse down event */
	function onmousedown(event) {
		event.preventDefault();
		hiddenInput.focus();
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;
		/* asks the space if it forces this to be a drag or click, or yet unknown */
		mst = this.space.mousedown(x, y);
		switch(mst) {
		case enums.MST_ATWEEN :
			msx = mmx = x;
			msy = mmy = y;
			atweenTimer = setTimeout("System.onatweentime();", settings.dragtime);
			break;
		case enums.MST_DRAG :
			captureEvents();
			break;
		}	
		return false;
	}

	/* mouse up event */
	function onmouseup(event) {
		event.preventDefault();
		releaseEvents();
		var x = event.pageX - canvas.offsetLeft;
		var y = event.pageY - canvas.offsetTop;
		
		switch (mst) {
		case enums.MST_NONE :
			/* console.log("mouse up, without down?"); */
			return false;
		case enums.MST_ATWEEN :
			/* this was a click */
			clearTimeout(atweenTimer);
			atweenTimer = null;
			this.space.click(x, y);
			mst = enums.MST_NONE;
			return false;
		case enums.MST_DRAG :
			this.space.dragstop(x, y);
			mst = enums.MST_NONE;
			return false;
		}
	}

	/* timeout after mouse down so dragging starts */
	function onatweentime() {
		if (mst != enums.MST_ATWEEN) {
			console.log("dragTime() in wrong action mode");
			return;
		}
		mst = enums.MST_DRAG;
		atweenTimer = null;
		this.space.dragstart(msx, msy);
		if (mmx != msx || mmy != msy) {
			this.space.dragmove(mmx, mmy);
		}
	}
	
	
	canvas.onmouseup       = this.makeCatcher(this, onmouseup);
	canvas.onmousemove     = this.makeCatcher(this, onmousemove);
	canvas.onmousedown     = this.makeCatcher(this, onmousedown);
	window.onresize        = this.makeCatcher(this, onresize);
	hiddenInput.onfocus    = this.makeCatcher(this, onfocus);
	hiddenInput.onblur     = this.makeCatcher(this, onblur);
	hiddenInput.onkeydown  = this.makeCatcher(this, onkeydown);
	hiddenInput.onkeypress = this.makeCatcher(this, onkeypress);
	hiddenInput.onkeyup    = this.makeCatcher(this, onkeyup);
	this.ontestinput       = this.makeCatcher(this, testinput);
	this.onatweentime      = this.makeCatcher(this, onatweentime);
	this.onblink           = this.makeCatcher(this, blink);
		
	/* sets the mouse cursor */
	this.setCursor = function(cursor) {
		canvas.style.cursor = cursor;
	}		
	
	/*-- Meshcraft System calls --*/
	
	/* clears the canvas */
	this.canvasClear = function() {
		cx.clearRect(0, 0, canvas.width, canvas.height);
		//canvas.width = canvas.width;
	}
		
	/* the blink (and check input) timer */
	var blinkTimer = null;
	
	/* (re)starts the blink timer */
	this.startBlinker = function() {
		if (blinkTimer) {
			clearInterval(blinkTimer);
		} 
		testinput();
		blinkTimer = setInterval("System.onblink()", settings.caretBlinkSpeed);		
	}
	
	/* stops the blink timer */
	this.stopBlinker = function() {
		if (blinkTimer) {
			clearInterval(blinkTimer);
		} 		
	}
		
	this.startBlinker();
	delete this.init;

	// -v-v-v- testing code here -v-v-v-v-
	var space = this.space = new Space();
	//var note1 = new Note(220, 65);
	//var note1 = new Note(320, 90);
	var note2 = new Note(500, 200);
	var vector1 = null;
	//vector1 = new VectorGraph(850, 200, note2.doc);
	//if (vector1) {
	//	space.addItem(vector1,  10,  10);
	//}
	//space.addItem(note1,    10,  10);
	//space.addItem(note2,   250, 240);
	space.addItem(note2, false, 50, 40);
	{
		var a=[];
		var n=0;
a[n++]="                                                         _.._";
a[n++]="                                                      .-'_.._''.";
a[n++]=" __  __   ___       _....._              .          .' .'     '.\\";
a[n++]="|  |/  `.'   `.   .Â´       '.          .'|         / .'                                _.._";
a[n++]="|   .-.  .-.   ' /   .-'\"'.  \\        (  |        . '            .-,.-~.              .' .._|    .|";
a[n++]="|  |  |  |  |  |/   /______\\  |        | |        | |            |  .-. |    __      | '      .' |_";
a[n++]="|  |  |  |  |  ||   __________|    _   | | .'''-. | |            | |  | | .:-`.'.  __| |__  .'     |";
a[n++]="|  |  |  |  |  |\\  (          '  .' |  | |/.'''. \\. '            | |  | |/ |   \\ ||__   __|'-..  .-'";
a[n++]="|  |  |  |  |  | \\  '-.___..-~. .   | /|  /    | | \\ '.         .| |  '- `\" __ | |   | |      |  |";
a[n++]="|__|  |__|  |__|  `         .'.'.'| |//| |     | |  '. `.____.-'/| |      .'.''| |   | |      |  |";
a[n++]="                   `'-.....-.'.'.-'  / | |     | |    `-._____ / | |     / /   | |_  | |      |  '.'";
a[n++]="                                 \\_.'  | '.    | '.           `  |_|     \\ \\._,\\ '/  | |      |   /";
a[n++]="                                       '___'   '___'                      `~~'  `\"   |_|      `'~~/";
		for(var i = 0; i < n; i++) {
//			note1.dtree.append(new Paragraph(a[i]));
		}
	}
	//note1.doc.textsize = 13;
	//note1.dtree.textsize = 3;
	//note1.dtree.font = note1.dtree.textsize + "px monospace";
	//note1.dtree.pre = true;
	
	//var draw = window.localStorage.getItem("draw");
	var draw = "";
	if (draw) {
		var reg = /([^\n]+)$/gm;
		for(var ca = reg.exec(draw); ca != null; ca = reg.exec(draw)) {
			note2.append(new Paragraph(ca[1]));
		}
		note2.doc.textsize = 10;
		note2.doc.font = note2.doc.textsize + "px monospace";
		note2.doc.pre = true;
	} else {
		var d = note2.dtree;
		d.append(new Paragraph("Lorem ipsum dolor sit amet, consectetur adipiscing elit. In sollicitudin tortor vehicula tellus vestibulum quis pharetra augue faucibus. Integer id quam urna. Aliquam accumsan pulvinar luctus."));
		d.append(new Paragraph("Fusce tincidunt, sapien posuere interdum rutrum, mauris ante consequat ipsum, id tincidunt nisl turpis ut lectus. Sed in elit ut neque placerat malesuada non vel turpis. Integer congue sem commodo justo pretium vestibulum. Pellentesque at libero eget quam blandit molestie. Nunc in lacus massa, quis faucibus justo."));
		d.append(new Paragraph("Aliquam vitae tellus nulla. Vestibulum at tortor sit amet ligula bibendum iaculis quis vitae sapien. Integer pellentesque ullamcorper arcu, volutpat aliquam mi viverra vel. Integer mollis, augue at pellentesque tristique, ante magna rutrum urna, vel sagittis sem elit in augue."));
		d.append(new Paragraph("Nam eros nunc, egestas porttitor pharetra sit amet, egestas eleifend eros. Nulla mauris felis, cursus eget tincidunt sed, pretium quis nibh. Proin pulvinar, enim sit amet tincidunt varius, diam risus bibendum augue, sed facilisis lectus massa in sem. Duis ac felis libero."));
	}
	space.redraw();	
}};

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hexagon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* shortcut globas */
var hexc = Math.cos(Math.PI / 6);
var hext = Math.tan(Math.PI / 6);
	
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--' .          .                    
 \|__  |  ,-. ,-. |- ,-,-. ,-. ,-. . . 
  |    |  | | ,-| |  | | | |-' | | | | 
 `'    `' `-' `-^ `' ' ' ' `-' ' ' `-^ 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Floatmenu() {
	this.x = null;
	this.y = null;
	this.radi = 25;
	this.rado = 60;
	this.fill = false;
	this.mousepos = -1;
}

Floatmenu.prototype._pathHex = function(cx, x, y, r) {
	var r2 = Math.round(0.5 * r);
	var rc = Math.round(hexc * r);

	cx.beginPath();
	cx.moveTo(x - r, y);
	cx.lineTo(x - r2, y - rc);
	cx.lineTo(x + r2, y - rc);
	cx.lineTo(x + r, y);
	cx.lineTo(x + r2, y + rc);
	cx.lineTo(x - r2, y + rc);
	cx.lineTo(x - r, y);
	cx.closePath();
}

Floatmenu.prototype._pathHex6 = function(cx, x, y, seg) {
	var ri = this.radi;
	var ro = this.rado;
	var ri2 = Math.round(0.5 * ri);
	var ric = Math.round(hexc * ri);	
	var ro2 = Math.round(0.5 * ro);
	var roc = Math.round(hexc * ro);
	
	cx.beginPath();
	cx.moveTo(x - ro2, y - roc);
	cx.lineTo(x + ro2, y - roc);
	cx.lineTo(x + ri2, y - ric);
	cx.lineTo(x - ri2, y - ric);
	cx.closePath();
}	

Floatmenu.prototype.draw = function() {
	var canvas = System.canvas;
	var cx = canvas.getContext("2d");
	cx.save();
	var x = this.x + 0.5;
	var y = this.y + 0.5;

	var grad = cx.createRadialGradient(x, y, 0, x, y, (this.rado + this.radi) / 2);
	grad.addColorStop(0, settings.floatMenuBackground1);
	grad.addColorStop(1, settings.floatMenuBackground2);
	
	this._pathHex(cx, x, y, this.rado - 1);
	cx.fillStyle = grad;
	cx.lineWidth = settings.floatMenuInnerBorderWidth;
	cx.strokeStyle = settings.floatMenuInnerBorderColor;
	cx.fill();
	//cx.stroke(); 
	
	this._pathHex(cx, x, y, this.rado);
	cx.lineWidth = settings.floatMenuOuterBorderWidth;
	cx.strokeStyle = settings.floatMenuOuterBorderColor;
	cx.stroke();
	
	this._pathHex(cx, x, y, this.radi);
	cx.stroke();

	this._pathHex6(cx, x, y, 0);
	if (this.mousepos == 1) {
		cx.fillStyle = settings.floatMenuFillStyle;
		cx.fill();
	}
	cx.stroke();
	
	cx.fillStyle = "black";
	cx.font = "10pt " + settings.defaultFont;
	cx.textAlign = "center";
	cx.textBaseline = "middle";
	cx.fillText("new", this.x, this.y);
	
	cx.fillText("Note", Math.round(this.x), Math.round(this.y - (this.rado - this.radi) * 1.1));
	cx.beginPath(); /* todo tidy up */
	cx.restore();
}

Floatmenu.prototype._getMousepos = function(x, y) {
	var tx = this.x;
	var ty = this.y;
	var ro = this.rado;
	var ri = this.radi;
	var ro2 = this.rado * hexc;
	var ri2 = this.radi * hexc;
	var roc = this.rado * hexc;
	var ric = this.radi * hexc;
	var yh = (y - ty) * hext;

	if (y < ty - roc || y > ty + roc ||
	    x - ro + yh >= tx ||
		x + ro + yh <= tx ||
		x - ro - yh >= tx ||
		x + ro - yh <= tx)
	{
		/* out of menu */
		return this.mousepos = -1;
	} else {
		var lor = x + (y - this.y) * hext <= this.x;
		var rol = x - (y - this.y) * hext >= this.x;
		if (y < ty - ric && lor && rol) {
			return this.mousepos = 1;
		} else {
			return this.mousepos = 0;
		}
	}
}


Floatmenu.prototype.mousehover = function(x, y) {
	var omp = this.mousepos;
	var mp = this._getMousepos(x, y);
	if (mp < 0) {
		return  mp != omp;
	}
	return mp != omp;
}

Floatmenu.prototype.mousedown = function(x, y) {
	return this._getMousepos(x, y);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.---.                 
\___  ,-. ,-. ,-. ,-. 
    \ | | ,-| |   |-' 
`---' |-' `-^ `-' `-' 
~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      ' 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Space() {
	/* all items in the space */
	this._items = []; 
	this._floatmenu = new Floatmenu();
	
	this.iaction = { /* todo private? */
		act : enums.ACT_NONE,
	};
			
	/* panning offset */
	this.pox = 0;
	this.poy = 0;
}

/* redraws the complete space */
Space.prototype.redraw = function() {
	var items = this._items;
	var editor = System.editor;
	var canvas = System.canvas;
	System.canvasClear();
	editor.caret.save = null;
	var cx = canvas.getContext("2d");

	for(var i = items.length - 1; i >= 0; i--) {
		var it = items[i];
		cx.drawImage(it.getCanvas(editor.selection), it.x + this.pox, it.y + this.poy);
	}
		
	/* draws resize handles */
	if (editor.item) {
		cx.save();
		var it = editor.item;
		var ds = settings.handleDistance; 			
		var hs = settings.handleSize;
		var hs2 = hs / 2;
			
		var x1 = it.x + 0.5 - ds + this.pox;
		var y1 = it.y + 0.5 - ds + this.poy;
		var x2 = x1 + it.width  + 2*ds - 1;
		var y2 = y1 + it.height + 2*ds - 1;
		var xm = Math.round((x1 - 0.5 + x2) / 2) + 0.5;
		var ym = Math.round((y1 - 0.5 + y2) / 2) + 0.5;
		
		cx.moveTo(x1, y1 + hs);  cx.lineTo(x1, y1); cx.lineTo(x1 + hs, y1);
		cx.moveTo(xm - hs2, y1); cx.lineTo(xm + hs2, y1);
		cx.moveTo(x2 - hs,  y1); cx.lineTo(x2, y1); cx.lineTo(x2, y1 + hs);
		cx.moveTo(x2, ym - hs2); cx.lineTo(x2, ym + hs2);
		cx.moveTo(x2, y2 - hs);  cx.lineTo(x2, y2); cx.lineTo(x2 - hs, y2);
		cx.moveTo(xm - hs2, y2); cx.lineTo(xm + hs2, y2);
		cx.moveTo(x1 + hs, y2);  cx.lineTo(x1, y2); cx.lineTo(x1, y2 - hs);
		cx.moveTo(x1, ym - hs2); cx.lineTo(x1, ym + hs2);
			
		cx.strokeStyle = settings.handleColor1;
		cx.lineWidth = settings.handleWidth1;
		cx.stroke(); 
		cx.strokeStyle = settings.handleColor2;
		cx.lineWidth = settings.handleWidth2;
		cx.stroke(); 
		cx.beginPath(); 
		cx.restore();
	}
				
	if (this.iaction.act == enums.ACT_FMENU) {
		this._floatmenu.draw();
	}
	editor.updateCaret();
}
		
/* adds an item to the space */
Space.prototype.addItem = function(item, top, x, y) {
	item.x = x;
	item.y = y;
	if (top) {
		this._items.unshift(item);
	} else {
		this._items.push(item);	
	}
}

/* user pressed a special key */
Space.prototype.specialKey = function(keyCode, shiftKey) {
	var rv = System.editor.specialKey(keyCode, shiftKey);
	if (rv) {
		this.redraw();
	}
}

/* user entered normal text (one character or more) */
Space.prototype.input = function(text) {
	if (System.editor.input(text)) {
		this.redraw();		
	}
}

/* the canvas/space got focus from the system*/
Space.prototype.systemFocus = function() {
	System.editor.systemFocus();
}

/* the canvas/space lost system focus */
Space.prototype.systemBlur = function() {
	System.editor.systemBlur();
}

/* gives one item the keyboard focus */
/*Space.prototype.focus = function(item) {
	item.focus(System.editor);
}*/

/* returns the item offset at position x, y */	
Space.prototype.itoAtXY = function(x, y) {
	for(var i = 0, len = this._items.length; i < len; i++) {
		var it = this._items[i];
		if (x >= it.x && y >= it.y &&  x <= it.x + it.width && y <= it.y + it.height) {
			return i;
		}
	}
	return -1;
}

/* returns the compass of the resize handles of an item */
function checkItemCompass(it, x, y) { /* todo move to item */
	var d = settings.handleSize;
	/* resize */
	var n = y >= it.y - d && y <= it.y + d;
	var e = x >= it.x + it.width - d && x <= it.x + it.width + d;
	var s = y >= it.y + it.height - d && y <= it.y + it.height + d;
	var w = x >= it.x - d && x <= it.x + d;
	
	if (n) {
		if (w) { 
			return "nw";
		} else if (e) {
			return "ne";
		} else {
			var mx = it.x + it.width / 2;
			if (x >= mx - d && x <= mx + d) {
				return "n";
			}
		}
	} else if (s) {
		if (w) {
			return "sw";
		} else if (e) {
			return "se";
		} else {
			var mx = it.x + it.width / 2;
			if (x >= mx - d && x <= mx + d) {
				return "s";
			}
		}
	} else if (w) {
		var my = it.y + it.height / 2;
		if (y >= my - d && y <= my + d) {
			return "w";
		}
	} else if (e) {
		var my = it.y + it.height / 2;
		if (y >= my - d && y <= my + d) {
			return "e";
		}
	}
	return null;
}


/* mouse hover */
Space.prototype.mousehover = function(x, y) {
	var px = x - this.pox;
	var py = y - this.poy;
	var com = null;
	var editor = System.editor;
	var redraw = false;
	if (this.iaction.act == enums.ACT_FMENU) {
		redraw = this._floatmenu.mousehover(x, y);
		if (this._floatmenu.mousepos >= 0) {
			/* mouse was over float, no need to look further */
			System.setCursor("default");
			if (redraw) this.redraw();
			return;
		}
	}
	
	if (editor.item) {
		var it = editor.item;
		com = checkItemCompass(it, px, py);
		if (com) {
			System.setCursor(com + "-resize");					
		}
	}
	if (!com) {
		var ito = this.itoAtXY(px, py); /* todo give a better name */
		if (ito < 0) {
			System.setCursor("crosshair");
		} else {
			System.setCursor("default");				
		}
	}
	if (redraw) this.redraw();
}

/* starts an operation with the mouse held down */
Space.prototype.dragstart = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var editor  = System.editor;
	var iaction = this.iaction; /* todo make underscored */
	var redraw = false;

	var ito = this.itoAtXY(x, y);
	if (ito < 0) {
		/* panning */
		iaction.act = enums.ACT_PAN;
		iaction.sx = x;
		iaction.sy = y;
		System.setCursor("pointer");
		return;
	} 
	
	/* dragging or scrolling */
	var it = this._items[ito];
	if (ito > 0) {
		/* moves item to top */
		this._items.splice(ito, 1);
		this._items.unshift(it);
		ito = 0;
		redraw = true;
	}
	/*  focus the item */
	if (editor.item != it) {
		it.focus(editor);
		redraw = true;
	}

	var srad = settings.scrollbarRadius;
	var sbmx = settings.scrollbarMarginX;
	if (it.scrolly >= 0 && Math.abs(x - it.x - it.width + srad + sbmx) <= srad +1)  {
		iaction.act = enums.ACT_SCROLLY; 
		iaction.item = it;
		iaction.sy   = y;
		iaction.ssy  = it.scrolly;
	} else {
		iaction.act = enums.ACT_IDRAG;
		iaction.item = it;
		iaction.sx = x - it.x;
		iaction.sy = y - it.y;
		System.setCursor("move");
	}
	if (redraw) {
		this.redraw();
	}
}

/* a click is a mouse down followed within dragtime by 'mouseup' and
 * not having moved out of 'dragbox'. */
Space.prototype.click = function(x, y) {
	var px = x - this.pox;
	var py = y - this.poy;
	var editor = System.editor;
	var iaction = this.iaction;
	var ito = this.itoAtXY(px, py);
	var it = this._items[ito];
	var redraw = false;
	
	if (ito < 0) {
		iaction.act = enums.ACT_FMENU;
		this._floatmenu.x = x;
		this._floatmenu.y = y;
		System.setCursor("default");
		editor.blur();
		redraw = true;
	} else {
		if (ito > 0) {
			/* moves item to top */
			this._items.splice(ito, 1);
			this._items.unshift(it);
			ito = 0;
			redraw = true;
		}
		/*  focus the item */
		if (editor.item != it) {
			it.focus(editor);
			redraw = true;
		}
		var ox = px - it.x;
		var oy = py - it.y + (it.scrolly > 0 ? it.scrolly : 0);
		if (it.paraAtY) { /* todo, make this less dirty, move the logic into the item or editor*/
			var p = it.paraAtY(oy);
			if (p) {
				editor.caret.setFromXY(p, ox - p.x, oy - p.y);
				editor.caret.show();
				redraw = true;
			}
		}
	}
			
	if (redraw) {
		this.redraw();
	}
}

/* stops an operation with the mouse held down */
Space.prototype.dragstop = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var editor = System.editor;
	var iaction = this.iaction;
	switch (iaction.act) {
	case enums.ACT_IDRAG :
		iaction.item.x = x - iaction.sx;
		iaction.item.y = y - iaction.sy;
		iaction.item = null;
		System.setCursor("default");
		this.redraw();
		break;
	case enums.ACT_PAN :
		break;
	case enums.ACT_IRESIZE :
		iaction.com  = null;
		iaction.item = null;
		iaction.six  = null;
		iaction.siy  = null;
		iaction.swi  = null;
		iaction.shi  = null;
		break;
	case enums.ACT_SCROLLY :
		iaction.ssy  = null;
		break;
	default :
		throw new Error("Invalid action in 'Space.dragstop'");
	}
	iaction.act = enums.ACT_NONE;
	iaction.sx   = null;
	iaction.sy   = null;
	return;
}

/* moving during an operation with the mouse held down */
Space.prototype.dragmove = function(x, y) {
	x -= this.pox;
	y -= this.poy;
	var iaction = this.iaction;
	
	switch(iaction.act) {
	case enums.ACT_PAN :
		this.pox += x - iaction.sx;
		this.poy += y - iaction.sy;
		this.redraw();
		return;
	case enums.ACT_IDRAG :
		iaction.item.x = x - iaction.sx;
		iaction.item.y = y - iaction.sy;
		this.redraw();
		return;
	case enums.ACT_IRESIZE :
	{
		var wi = iaction.swi;
		var hi = iaction.shi;
		var it = iaction.item;
		switch (iaction.com) {
		case "e"  : 
		case "ne" :
		case "se" :
			var wi = iaction.swi + x - iaction.sx;
			if (wi < settings.noteMinSizeX) {
				wi = settings.noteMinSizeX;
			}
			break;
		case "w"  :
		case "nw" :
		case "sw" :	
			var wi = iaction.swi - x + iaction.sx;
			if (wi < settings.noteMinSizeX) {
				wi = settings.noteMinSizeX;
			}
			it.x = iaction.six + iaction.swi - wi;
			break;
		}
		switch (iaction.com) {
		case "s"  : 
		case "sw" :
		case "se" :
			var hi = iaction.shi + y - iaction.sy;
			if (hi < settings.noteMinSizeY) {
				hi = settings.noteMinSizeY;
			}
			break;
		case "n"  : 
		case "nw" :
		case "ne" :
			var hi = iaction.shi - y + iaction.sy;
			if (hi < settings.noteMinSizeY) {
				hi = settings.noteMinSizeY;
			}
			it.y = iaction.siy + iaction.shi - hi;
			break;			
		}
		if (wi != iaction.swi || hi != iaction.shi) {
			it.resize(wi, hi);
			this.redraw();
		}
		var dtreeHeight = it.dtree.height;
		var smaxy = dtreeHeight - (it.height - 2 * it.textBorder);
		if (smaxy > 0 && it.scrolly > smaxy) {
			it.scrolly = smaxy;
			// todo split redraw into reflow and redraw.
			this.redraw();
		}		
		return;
	}
	case enums.ACT_SCROLLY:
	{
		var dy = y - iaction.sy;
		var it = iaction.item;
		var scrollRange = it.height - settings.scrollbarMarginY * 2;
		var dtreeHeight = it.dtree.height;
		var innerHeight = it.height - 2 * it.textBorder;
		var scrollSize  = scrollRange * innerHeight / dtreeHeight;
		var srad = settings.scrollbarRadius;
		if (scrollSize < srad * 2) {
			/* minimum size of scrollbar */
			scrollSize = srad * 2;
		}		
		var sy = iaction.ssy + 
			dy * (dtreeHeight - innerHeight) / (scrollRange - scrollSize);
		var smaxy = dtreeHeight - innerHeight;
		if (sy < 0) {
			sy = 0;
		} else if (sy > smaxy) {
			sy = smaxy;
		}

		it.scrolly = sy;
		this.redraw();
		return true;		
	}
	default :
		throw new Error("unknown action code in Space.dragging");
	}
}

/* mouse down event */
Space.prototype.mousedown = function(x, y) {
	var px = x - this.pox;
	var py = y - this.poy;
	
	var iaction = this.iaction;
	var editor = System.editor;
	var redraw = false;
	
	if (iaction.act == enums.ACT_FMENU) {
		var md = this._floatmenu.mousedown(x, y);
		iaction.act = enums.NONE;
		redraw = true;
		if (md >= 0) {
			if (md == 1) {				
				var nw = settings.newNoteWidth;
				var nh = settings.newNoteHeight;
				var note = new Note(nw, nh);
				note.dtree.append(new Paragraph(""));
				this.addItem(note, true, 
					Math.round(this._floatmenu.x - nw / 2), 
					Math.round(this._floatmenu.y - nh / 2));
			}
			if (redraw) this.redraw();
			return enums.MST_NONE;
		}
	}
		
	var com;
	if (editor.item && (com = checkItemCompass(editor.item, px, py))) {
		/* resizing */
		iaction.act  = enums.ACT_IRESIZE;
		iaction.com  = com;
		iaction.item = editor.item;
		iaction.sx   = px;
		iaction.sy   = py;
		iaction.swi  = editor.item.width;
		iaction.shi  = editor.item.height;
		iaction.six  = editor.item.x;
		iaction.siy  = editor.item.y;
		System.setCursor(com + "-resize");
		if (redraw) this.redraw();
		return enums.MST_DRAG;
	}
	
	if (redraw) this.redraw();
	return enums.MST_ATWEEN;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,--,--'                    .
 `- | ,-. ,-. ,-. ,-. ,-. ,-| ,-.
  , | |   |-' |-' | | | | | | |-'
  `-' '   `-' `-' ' ' `-' `-^ `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Part of a tree-structure.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Treenode.id = 1;
function Treenode(type) {
	this.type = type;
	this.id   = ++Treenode.id;
}

/* prints the structure */
/* todo remove after a while */
Treenode.prototype.dbgstructure = function() {
	var str = "[" + this.type + "-" + this.id;
	if (this.next) {
		str += " n-" + this.next.id;
	}
	if (this.prev) {	
		str += " p-" + this.prev.id;
	}
	if (this.first) {
		str += " f-" + this.first.id + " {";
		for(var nn = this.first; nn; nn = nn.next) {
			if (nn != this.first) {
				str += ", ";
			}
			str += nn.dbgstructure();
		}
		str += "}"
	}
	if (this.last) {
		str += " l-" + this.last.id;
	}
	str += "]";
	return str;
}

/* appends tnode to list of children */
Treenode.prototype.append = function(tnode) {
	if (tnode.parent) {
		throw new Error("append() on a node already part of a tree");
	}
	tnode.parent = this;
	if (!this.last) {
		this.first = this.last = tnode;
		tnode.prev = tnode.next = null;
	} else {
		this.last.next = tnode;
		tnode.prev = this.last;
		this.last = tnode;
		tnode.next = null;
	}
	tnode.tell = this.listen ? this : this.tell;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* inserts tnode before child bnode */
Treenode.prototype.insertBefore = function(tnode, bnode) {
	if (!bnode) {
		this.append(tnode);
		return
	}
	
	if (tnode.parent) {
		throw new Error("Treenode.append() on a node already part of a tree");
	}
	tnode.parent = this;
	
	if (bnode == this.first) {
		this.first.prev = tnode;
		tnode.next = this.first;
		this.first = tnode;
		tnode.prev = null;
	}
	/* debug check if child */
	if (debugNodes) for(var n=this.first; n != bnode; n = n.next) 
		if (!n) throw new Error("debugNodes");
	
	tnode.next = bnode;
	tnode.prev = bnode.prev;
	bnode.prev.next = tnode;
	bnode.prev = tnode;
	
	tnode.tell = this.listen ? this : this.tell;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* removes child tnode */
Treenode.prototype.remove = function(tnode) {
	/* debug check if child */
	if (debugNodes) for(var n= this.first; n != tnode; n = n.next) 
		if (!n) throw new Error("debugNodes");
	
	if (tnode == this.first) this.first = tnode.next;
	if (tnode == this.last) this.last = tnode.prev;
	if (tnode.next) tnode.next.prev = tnode.prev;
	if (tnode.prev) tnode.prev.next = tnode.next;
	if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
}

/* returns first anchestor of 'type' */
Treenode.prototype.anchestor = function(type) {
	var n;
	for(n = this; n && n.type != type; n = n.parent);
	if (!n) throw new Error("anchestor not there");
	return n;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,--,--'      .            .
 `- | ,-. . , |- ,-. ,-. ,-| ,-.
  , | |-'  X  |  | | | | | | |-'
  `-' `-' ' ` `' ' ' `-' `-^ `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Textnode.prototype = new Treenode;
Textnode.prototype.constructor = Textnode;
function Textnode(text)
{
	Treenode.call(this, "text");
	this._text = text ? text : "";
}

Object.defineProperty(Textnode.prototype, "text", {
	get: function() { 
		return this._text;
	},
	
	set: function(text) {
		if (this._text != text) {
			this._text = text;
			if (this.listen) this.listen(); else if (this.tell) this.tell.listen();
		}
	}
});

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--.                             .
  '|__/ ,-. ,-. ,-. ,-. ,-. ,-. ,-. |-.
  ,|    ,-| |   ,-| | | |   ,-| | | | |
  `'    `-^ '   `-^ `-| '   `-^ |-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~,| ~ ~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
                     `'         '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
Paragraph.prototype = new Treenode;
Paragraph.prototype.constructor = Paragraph;
function Paragraph(text)
{
	Treenode.call(this, "paragraph");
	var pcanvas = this._pcanvas = document.createElement("canvas");
	pcanvas.width = pcanvas.height = 0;
	pcanvas.actual == false; // todo move var otherplace
	this.append(new Textnode(text));
	this._width = null;	
	this.x = null;
	this.y = null;
}

/* (re)flows the Paragraph, positioning all chunks  */
Paragraph.prototype._flow = function() {
	if (this._flowActual) {
		return;
	}

	/* build position informations */
	this._flowActual = true;
	var pinfo = this._pinfo = [];
	var width = this._width;
	var dtree = this.anchestor("dtree");
	/* canvas is needed for font measurement */
	var textsize = dtree.textsize;
	var x = 0;
	var y = textsize;	
	Measure.font = dtree.font;
	var space = Measure.width(" ");
	var pline = 0;
	{
		var l = pinfo[pline] = [];
		l.x = x;
		l.y = y;
	}

	for(var node = this.first; node; node = node.next) {
		var t = node.text;
		var pchunk = 0;
		var reg = !dtree.pre ? (/(\s*\S+)\s?(\s*)/g) : (/(.+)()$/g);
		var stol = true; /* at start of line */
		for(var ca = reg.exec(t); ca != null; ca = reg.exec(t)) {
			/* text is a word plus hard spaces */
			var text = ca[1] + ca[2];
			var w = Measure.width(text);
			if (x + w + space > width) {
				if (!stol) {
					/* soft break */
					x = 0;
					y += Math.round(dtree.textsize * (dtree.pre ? 1 : 1.2));
					pline++;
					{
						var l = pinfo[pline] = [];
						l.x = x;
						l.y = y;
						pchunk = 0;
					}
					stol = true;
				} else {
					/* horizontal overflow */
				}
			}				
			pinfo[pline][pchunk++] = {
				x: x, 
				w: w,
				node: node,
				offset: ca.index, 
				text: text,
			};

			x += w + space;
			stol = false;
		}
	}
	/* returns the logical height (excluding letters bottombox)  */
	this._softHeight = y;
}

/* returns the logical height 
 * (without addition of box below last line base line ofr gpq etc.) */
Object.defineProperty(Paragraph.prototype, "softHeight", {
	get: function() { 
		this._flow();
		return this._softHeight;
	},
	set: function(s) { throw new Error("Cannot set paragraph softHeight."); }
});

/* returns the computes size of the paragraph */
Object.defineProperty(Paragraph.prototype, "height", {
	get: function() { 
		var dtree = this.anchestor("dtree");
		return this._softHeight + Math.round(dtree.textsize * 0.27);
	},
	set: function(s) { throw new Error("Cannot set paragraph height."); }
});

/* return the position information */
Object.defineProperty(Paragraph.prototype, "pinfo", {
	get: function() { 
		this._flow();
		return this._pinfo;
	},
	set: function(s) { throw new Error("Cannot set pinfo");	}
});

Object.defineProperty(Paragraph.prototype, "width", {
	get: function() { 
		return this._width;
	},
	
	set: function(width) {
		if (this._width != width) {
			this._width = width;
			this._flowActual = false;
			this._canvasActual = false;
		}
	}
});

/* draws the paragraph in its cache and returns it */
Paragraph.prototype.getCanvas = function() {
	var pcanvas = this._pcanvas;
	if (this._canvasActual) {
		return pcanvas;
	}
	var cx = pcanvas.getContext("2d");
	this._flow();
	this._canvasActual = true;
			
	/* todo: work out exact height for text below baseline */
	/* set the canvas height */
	var dtree = this.anchestor("dtree");
	{
		var equalHeight = pcanvas.height == this.height;
		var equalWidth  = pcanvas.width  == this._width;
		if (equalHeight && equalWidth) {
			cx.clearRect(0, 0, this._width, this.height);
		} else {
			if (!equalHeight) {
				pcanvas.height = this.height;
			}
			if (!equalWidth) {
				pcanvas.width = this._width;
			}
		}
	}
	
	cx.font = dtree.font;	
	cx.fillStyle = "black";
	/* draws text into the canvas */
	var pinfo = this._pinfo;
	var plines = pinfo.length;
	for(var il = 0; il < plines; il++) {
		var pl = pinfo[il];
		var plen = pl.length;
		for(var ic = 0; ic < plen; ic++) {
			var pc = pl[ic];
			cx.fillText(pc.text, pc.x, pl.y);
		}
	}
	return pcanvas;
}
		
/* drops the canvas cache (cause something has changed */
Paragraph.prototype.listen = function() {
	this._flowActual   = false;
	this._canvasActual = false;
	if (this.tell) this.tell.listen();
}
		
/* join a child node to its next sibling, 
 * or joins this paragraph to its next sibling */
 /* todo, this doesnt belong here */
Paragraph.prototype.joinToNext = function(node, caret) {
	var next = node.next;
	if (next) {
		alert("joinToNext, not yet implemented");
	}
	var nextPara = this.next;
	if (nextPara == null) {
		/* end of document */
		return false;
	}
	node.text = node.text + nextPara.first.text;
	/* todo take over siblings */
	this.parent.remove(nextPara);
	return true;
}
	
/* join a child node to its previous sibling, 
 * or joins this paragraph to its previos sibling */
Paragraph.prototype.joinToPrevious = function(node, caret) {
	var prev = node.prev;
	if (prev) {
		alert("joinToPrevious, not yet implemented");
	}
	var prevPara = this.prev;
	if (prevPara == null) {
		return false;
	}
	var nt = node.text;
	var plc = prevPara.last;
	if (caret) {
		caret.set(plc, plc.text.length);
	}
	plc.text = plc.text + nt; 
	this.parent.remove(this);
	return true;
}
	
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .-,--.  ,--,--'
 ' |   \ `- | ,-. ,-. ,-.
 , |   /  , | |   |-' |-'
 `-^--'   `-' '   `-' `-'
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 A document with nodes in tree structure.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
DTree.prototype = new Treenode;
DTree.prototype.constructor = DTree;
function DTree() {
	Treenode.call(this, "dtree");
	this.textsize = 13;
	this.font = this.textsize + 'px ' + settings.defaultFont;
}
		
/* returns the chunk at x,y */
DTree.prototype.paraAtY = function(y) {
	var p = this.first;
	while (p && y > p.y + p.softHeight) {
		p = p.next;
	}
	return p;
}

/* draws the content in a buffer canvas */
/* acanvas  ... canvas to draw upon */
/* todo rename */
DTree.prototype.drawCanvas = function(acanvas, offsetX, offsetY, scrolly) {
	var cx = acanvas.getContext("2d");
	var y = offsetY;
	var pi = 0;
	var h = 0;
	var parasep = this.pre ? 0 : this.textsize;

	for(var para = this.first; para; para = para.next) {
		var pcanvas = para.getCanvas();
		para.x = offsetX;
		para.y = y;
		cx.drawImage(pcanvas, offsetX, y - scrolly);
		y += para.softHeight + parasep;
	}
}

/* Overloads Treenodes append to set the paragraph width */
DTree.prototype.append = function(tnode) {
	if (this._width) {
		tnode.width = this._width;
	}
	return Treenode.prototype.append.call(this, tnode);
}


/* Overloads Treenodes insertBefore to set the paragraph width */
DTree.prototype.insertBefore = function(tnode, bnode) {
	if (this._width && bnode) { 
		/* if not bnode append will be called */
		tnode.width = this._width;
	}
	return Treenode.prototype.insertBefore.call(this, tnode, bnode);
}

Object.defineProperty(DTree.prototype, "width", {
	get: function() { 
		return this._width;
	},
	set: function(width) {
		if (this._width != width) {
			this._width = width;
			for(var para = this.first; para; para = para.next) {
				para.width = width;
			}
		}
	}
});

Object.defineProperty(DTree.prototype, "height", {
	get: function() { 
		/* todo caching */
		var h = 0;
		var parasep = this.pre ? 0 : this.textsize;
		var first = true;
		for(var para = this.first; para; para = para.next) {
			if (para._width != this._width) {
				throw new Error("width violation");
			}
			if (!first) {
				h += parasep;
			} else {
				first = false;
			}
			h += para.softHeight;
		}
		return h;
	},
	
	set: function(width) { throw new Error("Cannot set height of DTree"); }
});

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,-_/ .
 '  | |- ,-. ,-,-.
 .^ | |  |-' | | |
 `--' `' `-' ' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 
 Something on a canvas.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Item(width, height) {
/* todo, not used! */
   this.width  = width;
   this.height = height;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
,-,-.       .      
` | |   ,-. |- ,-. 
  | |-. | | |  |-' 
 ,' `-' `-' `' `-' 
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 An item with text and a scrollbar.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function Note(width, height) {
	this.bcanvas = document.createElement("canvas");
	this.textBorder = settings.noteTextBorder;
	this.bcanvas.actual = false;
	
	this.width  = width;
	this.height = height;
	this._scrollx = -8833;
	this._scrolly = -8833;
	this.bcanvas.width  = width; /* need to set it so early? */
	this.bcanvas.height = height;
	this.dtree = new DTree();
	this.dtree.tell = this;
}

/* returns the para at y */
Note.prototype.paraAtY = function(y) {
	if (y < this.textBorder) {
		return null;
	}
	return this.dtree.paraAtY(y);
}

/* drops the cached canvas */
Note.prototype.listen = function() {
	this.bcanvas.actual = false;
}
	
/* resizes the note */
Note.prototype.resize = function(width, height) {
	if (this.width == width && this.height == height) {
		return;
	}
	var bcanvas = this.bcanvas;
	this.width  = bcanvas.width  = width; /* todo, not yet do sizing */
	this.height = bcanvas.height = height;
	bcanvas.actual = false;
}

Object.defineProperty(Note.prototype, "scrolly", {
	get: function() { 
		return this._scrolly;
	},
	
	set: function(sy) {
		if (sy < 0 && sy != -8833) {
			throw new Error("Invalid scrolly position");
		}
		if (this._scrolly != sy) {
			this._scrolly = sy;
			this.bcanvas.actual = false;
		}
	}
});

/* draws a bevel */
function Note_bevel(cx, x, y, w, h, border, radius) {
	var x1 = x + border;
	var y1 = y + border;
	var x2 = x + w - border;
	var y2 = y + h - border;
			
	cx.moveTo(x1 + radius, y1);
	cx.arc(x2 - radius, y1 + radius, radius, -Math.PI / 2, 0, false);
	cx.arc(x2 - radius, y2 - radius, radius, 0, Math.PI / 2, false);
	cx.arc(x1 + radius, y2 - radius, radius, Math.PI / 2, Math.PI, false);
	cx.arc(x1 + radius, y1 + radius, radius, Math.PI, -Math.PI / 2, false);
}
	
/* gets the canvas buffer for this item */
Note.prototype.getCanvas = function(select) {
	var bcanvas = this.bcanvas;
	var dtree = this.dtree;
	var cx = bcanvas.getContext("2d");
	if (bcanvas.actual) {
		/* buffer hit */
		return bcanvas;
	}

	/* draws the background */
	cx.clearRect(0, 0, bcanvas.width, bcanvas.height);	
	Note_bevel(cx, 0, 0, this.width, this.height, 2.5, 3);
	var grad = cx.createLinearGradient(0, 0, this.width / 10, this.height);			
	grad.addColorStop(0, settings.noteBackground1);
	grad.addColorStop(1, settings.noteBackground2);
	cx.fillStyle = grad;
	cx.fill();
	cx.fillStyle = "#000000";

	/* calculates if a scrollbar is needed */
	var sy = this._scrolly;
	var innerHeight = this.height - 2 * this.textBorder;
	dtree.width = this.width  - 2 * this.textBorder - (sy >= 0 ? settings.scrollbarRadius * 2 : 0);
	var dtreeHeight = dtree.height;
	if (sy < 0) {
		if (dtreeHeight > innerHeight) {
			/* should use a scrollbar */
			sy = this._scrolly = 0;		
			dtree.width = this.width  - 2 * this.textBorder - (sy >= 0 ? settings.scrollbarRadius * 2 : 0);
			dtreeHeight = dtree.height;
			if (dtreeHeight <= innerHeight) {
				throw new Error("note doesnt fit with and without scrollbar.");			
			}
		}
	} else if (dtreeHeight <= innerHeight) {
		/* should not use a scrollbar */
		sy = this._scrolly = -8833;
		dtree.width = this.width  - 2 * this.textBorder - (sy >= 0 ? settings.scrollbarRadius * 2 : 0);
		dtreeHeight = dtree.height;
		if (dtreeHeight > innerHeight) {
			throw new Error("note doesnt fit with and without scrollbar.");			
		}
	}
	
	/* draws the selection */
	if (select.active && select.begin.item == this) {
		var b = select.begin;
		var e = select.end;
		b.getXY();
		e.getXY();
		if (e.y < b.y) {
			e = select.begin;
			b = select.end;
		} else if (e.y == b.y && e.x < b.x) {
			e = select.begin;
			b = select.end;		
		}
		
		cx.fillStyle   = settings.selectionColor;
		cx.strokeStyle = settings.selectionStroke;
		cx.beginPath();
		var psy = sy >= 0 ? sy : 0;
		var lh = Math.round(this.dtree.textsize * 1.2);
		var bx = Math.round(b.x) + 0.5;
		var by = Math.round(b.y - psy) + 0.5;
		var ex = Math.round(e.x) + 0.5;
		var ey = Math.round(e.y - psy) + 0.5;
		var rx = Math.round(dtree.width + this.textBorder / 2) + 0.5;
		var lx = Math.round(this.textBorder / 2) + 0.5;
		if ((Math.abs(by - ey) < 2)) {
			// ***
			cx.moveTo(bx, by);
			cx.lineTo(bx, by + lh);
			cx.lineTo(ex, ey + lh);
			cx.lineTo(ex, ey);
			cx.lineTo(bx, by);
			cx.stroke();
			cx.fill();			
		} else if (Math.abs(by + lh - ey) < 2 && (bx >= ex))  {
			//      ***
			// ***
			cx.moveTo(rx, by + lh);
			cx.lineTo(bx, by + lh);
			cx.lineTo(bx, by);
			cx.lineTo(rx, by);
			
			cx.moveTo(lx, ey);
			cx.lineTo(ex, ey);
			cx.lineTo(ex, ey + lh);
			cx.lineTo(lx, ey + lh);
			cx.stroke();
			cx.fill();
		} else {
			//    *****
			// *****
			for(var i = 0; i < 2; i++) {
				cx.beginPath();
				var edge = i ? cx.moveTo : cx.lineTo;
				cx.moveTo(rx, ey);
				cx.lineTo(ex, ey);
				cx.lineTo(ex, ey + lh);
				cx.lineTo(lx, ey + lh);
				edge.call(cx, lx, by + lh);
				cx.lineTo(bx, by + lh);
				cx.lineTo(bx, by);
				cx.lineTo(rx, by);
				edge.call(cx, rx, ey);
				if (i) cx.stroke(); else cx.fill();
			}			
		}
		cx.beginPath();
	}
	
	/* draws text */	
	dtree.drawCanvas(bcanvas, 
		this.textBorder, this.textBorder, 
		sy < 0 ? 0 : Math.round(sy)
	);
	
	if (sy >= 0) {
		if (dtreeHeight <= innerHeight) {
			/* should not use a scrollbar */
			return null;
		}

		/* draws the vertical scroll bar */
		cx.fillStyle   = settings.scrollbarFillStyle;
		cx.strokeStyle = settings.scrollbarStrokeStyle;
		cx.lineWidth   = settings.scrollbarLineWidth;
		
		var srad        = settings.scrollbarRadius;
		var spx = this.width - settings.scrollbarMarginX - srad;
		var scrollRange = this.height - settings.scrollbarMarginY * 2;
		var scrollSize  = scrollRange * innerHeight / dtreeHeight;
		if (scrollSize < srad * 2) {
			/* minimum size of scrollbar */
			scrollSize = srad * 2;
		}
						
		var spy = settings.scrollbarMarginY + 
			sy / (dtreeHeight - innerHeight) * (scrollRange - scrollSize);
			sy / (dtreeHeight - innerHeight) * (scrollRange - scrollSize);
		
		switch (settings.scrollbarForm) {
		case 'round' :
			cx.beginPath();
			cx.arc(spx, spy + srad, srad, Math.PI, 0, false);
			cx.arc(spx, spy + scrollSize - srad, srad, 0, Math.PI, false);
			cx.closePath();
			cx.stroke();
			cx.fill();
			break;
		case 'square' :
			cx.fillRect(spx, spy, srad + 2, scrollSize);
			break;
		case 'hexagonh' :
			cx.beginPath();
			cx.moveTo(spx -   1 * srad, spy + hexc * srad);
			cx.lineTo(spx - 0.5 * srad, spy);
			cx.lineTo(spx + 0.5 * srad, spy);
			cx.lineTo(spx +   1 * srad, spy + hexc * srad);
			cx.lineTo(spx +   1 * srad, spy + scrollSize - hexc * srad);
			cx.lineTo(spx + 0.5 * srad, spy + scrollSize);
			cx.lineTo(spx - 0.5 * srad, spy + scrollSize);
			cx.lineTo(spx -   1 * srad, spy + scrollSize - hexc * srad);
			cx.closePath();
			cx.stroke();
			cx.fill();
			break;
		case 'hexagonv' :
			cx.beginPath();
			cx.moveTo(spx - 1 * srad, spy + hexc * srad);
			cx.lineTo(spx           , spy);
			cx.lineTo(spx + 1 * srad, spy + hexc * srad);
			cx.lineTo(spx + 1 * srad, spy + scrollSize - hexc * srad);
			cx.lineTo(spx           , spy + scrollSize);
			cx.lineTo(spx - 1 * srad, spy + scrollSize - hexc * srad);
			cx.closePath();
			cx.stroke();
			cx.fill();
			break;
		default :
			throw new Error("invalid settings.scrollbarForm");
		}
	}

	/* draws the border */
	cx.beginPath(); 
	cx.lineWidth = settings.noteInnerBorderWidth;
	cx.strokeStyle = settings.noteInnerBorderColor;
	Note_bevel(cx, 0, 0, this.width, this.height, 1.5, 4);
	cx.stroke(); cx.beginPath(); cx.closePath();
	cx.lineWidth = settings.noteOuterBorderWidth;
	cx.strokeStyle = settings.noteOuterBorderColor;
	Note_bevel(cx, 0, 0, this.width, this.height, 0.5, 5);
	cx.stroke(); cx.beginPath(); cx.closePath();
	cx.restore();
	bcanvas.actual = true;			 /* todo move */
	return bcanvas;	
}
	
/* item gets focus */
Note.prototype.focus = function(editor) {
	editor.focus(this);
	this.bcanvas.actual = false;
	editor.caret.show();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
,.   ,.       .          ,---.              .
`|  / ,-. ,-. |- ,-. ,-. |  -'  ,-. ,-. ,-. |-.
 | /  |-' |   |  | | |   |  ,-' |   ,-| | | | |
 `'   `-' `-' `' `-' '   `---|  '   `-^ |-' ' '
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ,-.|~ ~ ~ ~ ~ | ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 Something that draws     `-+' vectors  '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
function VectorGraph(width, height, doc)
{
	this.bcanvas = document.createElement("canvas");
	this.width  = bcanvas.width  =  width;
	this.height = bcanvas.height = height;
	this.doc = doc;
}

/* gets the canvas buffer for this item */
/* if caret != null draws the caret into the canvas */
VectorGraph.prototype.getCanvas = function() {
	var cx = this.bcanvas.getContext("2d");
	cx.beginPath();
	cx.clearRect(0, 0, bcanvas.width, bcanvas.height);
	draw = "";
	for(var para = doc.getFirstPara(); para; para = para.next) {
		var cmd = para.first.text;
		draw += cmd + "\n";
		var reg = /(\S+)\s*/g;
		var cc = [];
		var ci = 0;
		for(var ca = reg.exec(cmd); ca != null; ca = reg.exec(cmd)) {
			/* text is a word plus hard spaces */
			cc[ci++] = ca[1]; 
		}
		switch (cc[0]) {
		case 'A' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			var a5 = parseFloat(cc[5]);
			var a6 = parseFloat(cc[6]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" ||
			    typeof(a5) != "number" ||
			    typeof(a6) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.arc(a1, a2, a3, a4 * Math.PI / 4, a5 * Math.PI / 4, a6 > 0 ? true : false);
			break;
		case '.' :			
			cx.closePath();
			break;
			case 'F' :			
			cx.fill();
			cx.beginPath();
			break;
		case 'B' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			var a5 = parseFloat(cc[5]);
			var a6 = parseFloat(cc[6]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" ||
			    typeof(a5) != "number" ||
			    typeof(a6) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.bezierCurveTo(a1, a2, a3, a4, a5, a6);
			break;
		case 'Q' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			var a4 = parseFloat(cc[4]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number" ||
			    typeof(a4) != "number" 
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.quadraticCurveTo(a1, a2, a3, a4, a5, a6);
			break;
		case 'M' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.moveTo(a1, a2);
			break;
		case 'L' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.lineTo(a1, a2);
			break;
		case 'S' :
			cx.stroke();
			cx.beginPath();
			break;
		case 'c' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.strokeStyle = "rgb(" + a1 + "," + a2 + "," + a3 +")";
			break;
		case 'C' :
			var a1 = parseFloat(cc[1]);
			var a2 = parseFloat(cc[2]);
			var a3 = parseFloat(cc[3]);
			if (typeof(a1) != "number" || 
			    typeof(a2) != "number" ||
			    typeof(a3) != "number"
			) {
				//msg("Arguments not numbers: " + cmd);
				break;
			}
			cx.fillStyle = "rgb(" + a1 + "," + a2 + "," + a3 +")";
			break;
		case 'W' :
			var a1 = parseFloat(cc[1]);
			if (typeof(a1) != "number") {
				//msg("Arguments not numbers: " + cmd);
				break;
			}				
			cx.lineWidth = a1;
		case '' :
			break;
		default :
			//msg("Unknown command: " + cmd);
			break;
		}
	}			
	return bcanvas;
}
	
/* item gets focus */
VectorGraph.prototype.focus = function(editor) {
	return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ,.   ,   ,.       .
 `|  /|  / . ,-. ,-| ,-. . , ,
  | / | /  | | | | | | | |/|/
  `'  `'   ' ' ' `-^ `-' ' '
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
window.onload = function() {
	System.init();
}

//]]></script>
</head>
<body style="margin: 0; overflow: hidden;">
<textarea id="input" style="position: absolute; top:-200px;"></textarea>
<canvas id="canvas">
  You need a browser that supports HTML5 Canvas elements!
</canvas>
<!--div id="output" style="white-space: pre; font-family: monospace"></div-->
<br/><br/>
</body>
</html>